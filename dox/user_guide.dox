/*!
\page userGuide User Guide

<p>
This is a user guide that describe the specifications for the URBAN - Universal Robust Binary Assembler-Nator.
There are 4096 words (32 bits each) of location counter relative addressable memory that is available to a user.
We used Java as the language for constructing this while using Eclipse as an IDE.
The exact specifications of this language can be seen below.
</p>
<h1 id="toc">Table of contents</h1>
<ol>
  <li><a href="#hardware">Hardware Specifications</a></li>
  <li><a href="#instructionspec">Instruction Specifications</a></li>
  <li><a href="#symbols">Symbol Classifications </a></li>
  <li><a href="#valtypes">Value Types</a></li>
  <li><a href="#addrstat">Address Status Flags</a></li>
  <li><a href="#directivespec">Directive Specifications </a></li>
  <li><a href="#syntax">Syntax Specifications </a></li>
  <li><a href="#directives">Directives</a></li>
  <li><a href="#keywords">Operand Keywords</a></li>
  <li><a href="#instructions">Instructions</a></li>
  <li><a href="#objfile">Object File Specification</a></li>
  <li><a href="#loadfile">Load File Specification</a></li>
  <li><a href="#sampleio">URBAN Legend Input and Output Description and Format</a></li>
</ol>

<h1 id="hardware">Hardware Specifications<a href="#toc" class="backlink">Back to Top</a></h1>
<p>The table below illustrates the Hardware specifications of the URBAN machine.</p>

<table>
<tr>
  <th colspan="2">Specification</th>
  <th>Hardware Item</th>
  <th>Details</th>
</tr>
<tr>
  <td colspan="2">H1</td>
  <td>Processor</td>
  <td>The URBAN machine incorporates a 10.2 GHz Meyer 1.0 CPU, implemented using
      600-picometer technology with a liquid-helium-based cooling system.</td>
</tr>
<tr>
  <td colspan="2">H2</td>
  <td>Word Size</td>
  <td>The URBAN architecture uses 32-bit words.</td>
</tr>
<tr>
  <td colspan="2">H2</td>
  <td>Memory</td>
  <td>Memory in the URBAN architecture is word addressable and is guaranteed to be
      4096 words in size. Memory uses 16 micrometer technology and is passively
      cooled; at least 20,000 clock cycles are required per read, plus sync time.
      Addresses are 12 bits, ranging from 0 to 4095 (FFF<sub>16</sub>).</td>
</tr>
<tr>
  <td colspan="2">H3</td>
  <td>Registers</td>
  <td>The URBAN machine contains a total of 15 registers.</td>
</tr>
<tr>
  <td rowspan="2" class="stripebg"></td><td width="48">H3.1</td>
  <td>Arithmetic Registers</td>
  <td>Of the 15, eight are reserved for use with arithmetic.</td>
</tr>
<tr>
  <td width="48">H3.2</td>
  <td>Indexed Registers</td>
  <td>Of the fifteen, seven may be used to alter an address in certain instructions.</td>
</tr>
 
<tr>
  <td colspan="2">H4</td>
  <td>Arithmetic Unit</td>
  <td>Literals in the URBAN architecture are represented using two's compliment format.
      Addresses and registers are represented in unsigned format.</td>
</tr>
<tr>
  <td colspan="2">H5</td>
  <td>Internal Representations</td>
  <td>Internally, all values are stored as words (32 bit).</td>
</tr>
<tr>
  <td rowspan="2" class="stripebg"></td><td width="32">H5.1</td>
  <td>Numbers</td>
  <td>When representing a number, the high-order bit serves as a sign bit. By specification H4,
      the range for all numbers is therefore (-2<sup>32</sup>) to (2<sup>32</sup>-1).</td>
</tr>
<tr>
  <td width="32">H5.2</td>
  <td>Characters</td>
  <td>When representing strings of characters, UTF-8 encoding is used, and the word is interpreted as a
      string of four 8-bit UTF-8 characters.</td>
</tr>
<tr>
  <td colspan="2">H6</td>
  <td>Addressing</td>
  <td>As stated in specification H2, memory in the the URBAN machine is <i>word</i> addressable, <b>not</b> byte addressable.</td>
</tr>
</table>


<h1 id="instructionspec">Instruction Specifications<a href="#toc" class="backlink">Back to Top</a></h1>
<p>Instructions in the URBAN language follow the same basic format:</p>

<p>
<span style="color:#ff0000"><b>OPCODE</b></span>(6b),
<span style="color:#ff6600"><b>FORMAT</b></span>(1b),
<span style="color:#009900"><b>IS_LITERAL</b></span>(1b),
<span style="color:#339999"><b>SOURCE</b></span>,
<span style="color:#3333ff"><b>DESTINATION</b></span>,
<span style="color:#cc33cc"><b>DATA</b></span>(16b).
</p>

<p>This structure allows for easy hand-assembly, as the only nybble sharing is between the opcode and format. For example, <tt>MOVD FR:1, DR:2;</tt> assembles to 
<span style="color:#ff0000">0</span><span style="color:#ff6600">0</span><span style="color:#339999">1</span><span style="color:#3333ff">2</span><span style="color:#cc33cc">0000</span>.</p>

The <span style="color:#339999"><b>SOURCE</b></span> and
<span style="color:#3333ff"><b>DESTINATION</b></span> nybbles
are identical; they are laid out as a single bit representing 
the type of the item followed by three bits for the register number.<br>

<ul>
  <li><b>0</b> <i>000</i> - <b>0</b> <i>111</i> Are arithmetic registers 0 - 7, as specified in H3.1.</li>
  <li><b>1</b> <i>001</i> - <b>1</b> <i>111</i> Are index registers, 1 - 7, as specified in H3.2.</li>
  <li><b>1</b> <i>000</i> Is an invalid index register, and is used to indicate that the <span style="color:#cc33cc"><b>DATA</b></span> member is used.</li>
</ul>

<p>The <span style="color:#cc33cc"><b>DATA</b></span> field is sixteen
bits, and is only used as described in the points above. If the 
<span style="color:#009900"><b>IS_LITERAL</b></span> bit is set, all sixteen bits of the
<span style="color:#cc33cc"><b>DATA</b></span> member are used as the literal,
and the value can range from -32768 to 32767 as per specification H4. If the 
<span style="color:#009900"><b>IS_LITERAL</b></span> bit is not set, then the
<span style="color:#cc33cc"><b>DATA</b></span> member is broken into an indexed
address; the first nybble gives the index register, or zero for none, and the next
three nybbles denote the address. Should the size of the memory for the machine grow,
a bit can be removed from the first nybble and given to the second.</p>

An illustration of the breakdown of these formats is given in the two following tables:
<table>
  <tr>
    <th>Format</th>
    <td colspan="6"><span style="color:#ff0000"><b>OPCODE</b></span>       </td>
    <td colspan="1"><span style="color:#ff6600"><b>FORMAT</b></span>       </td>
    <td colspan="1"><span style="color:#009900"><b>IS_LITERAL</b></span>   </td>
    <td colspan="4"><span style="color:#339999"><b>SOURCE</b></span>       </td>
    <td colspan="4"><span style="color:#3333ff"><b>DESTINATION</b></span>  </td>
    <td colspan="16"><span style="color:#cc33cc"><b>DATA</b></span>        </td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Memory</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="4"><b>IXR</b></td>
    <td colspan="12"><b>Memory address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>1</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Literal</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="16"><b>Literal</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>1</b></td>
    <td>1</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">DEST-Mem</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="4"><b><i>Word Count</i></b></td>
    <td colspan="4"><b>IXR</b></td>
    <td colspan="12"><b>Memory address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>1</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">SRC-Mem</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="4"><b><i>Word Count</i></b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="4"><b>IXR</b></td>
    <td colspan="12"><b>Memory address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>0</td><td>0</td><td>0</td><td>1</td>
    <td>1</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">OP-Literal</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="16"><b>Literal</b></td>
  </tr>
  <tr>
    <td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td>
    <td><b>0</b></td><td><b>1</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">OP Only</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Unused</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="16"><b>Unused</b></td>
  </tr>
  <tr>
    <td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
</table>

<br/>

<p>When the format bit is set, the source and destination expand to consume the entire 3-byte remainder, as shown:</p>
<table>
  <tr>
    <th>Format</th>
    <td colspan="6"> <span style="color:#ff0000"><b>OPCODE</b></span>       </td>
    <td colspan="1"> <span style="color:#ff6600"><b>FORMAT</b></span>       </td>
    <td colspan="1"> <span style="color:#009900"><b>IS_LITERAL</b></span>   </td>
    <td colspan="12"><span style="color:#339999"><b>SOURCE</b></span>       </td>
    <td colspan="12"><span style="color:#3333ff"><b>DESTINATION</b></span>  </td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Memory + Memory</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="12"><b>Address 1</b></td>
    <td colspan="12"><b>Address 2</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>1</b></td><td><b>0</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Literal + Memory</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="12"><b>Literal</b></td>
    <td colspan="12"><b>Address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>1</b></td><td><b>1</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
</table>

Combinations that can not be used in the above formats include the following:<br>
<ul>
  <li>Indexed memory with memory: FM,DM,DX; <i>or</i> FM,FX,DM<br></li>
  <li>Indexed memory with indexed memory: FM,FX,DM,DX;</li>
  <li>Literal and indexed memory: FL,DM,DX;</li>
  <li>Dual-destination transfers: FR,DR,DX; <i>or</i> FM,DR,DX<br></li>
</ul>

<h1 id="symbols">Symbol Classifications <a href="#toc" class="backlink">Back to Top</a></h1>
<table>
  <tr>
    <th colspan="2">Classification</th>
    <th>RegExp</th>
    <th>Description</th>
  </tr>
  <tr>
    <td colspan="2"><a name="letter">Letter</a></td>
    <td>[a-zA-Z_]</td>
    <td>The ASCII characters 'a'-'z' and 'A'-'Z', and the underscore character '_'.
  </tr>
  <tr>
    <td colspan="2"><a name="letter">Digit</a></td>
    <td>[0-9]</td>
    <td>Decimal digits for use as integer literals.</td>
  </tr>
  <tr>
    <td colspan="2"><a name="controlchar">Control Character</a></td>
    <td>[;:,+-\\*\\/]</td><td>Symbols carrying syntactical meaning as operators or separators.</td>
    </tr><tr><td rowspan="7" class="stripebg">
    </td>    <td>;</td><td>;</td><td>Semicolons are used to separate instructions and begin comments.</td>
    </tr><tr><td>:</td><td>:</td><td>Colons are used to denote the start of an operand's value.</td>
    </tr><tr><td>,</td><td>,</td><td>Commas are used to separate individual operands to the same instruction.</td>
    </tr><tr><td>+</td><td>\\+</td><td>The plus symbol denotes addition; it can only be used in operand expressions.</td>
    </tr><tr><td>-</td><td>-</td><td>The minus symbol denotes addition; it can only be used in operand expressions.</td>
    </tr><tr><td>*</td><td>\\*</td><td>The asterisk (*) denotes the current location counter in operand expressions.</td>
    </tr><tr><td>/</td><td>\\/</td><td>The division symbol (/) is reserved for future use.</td>
  </tr>
  <tr>
    <td colspan="2"><a name="white">Whitespace</a></td>
    <td>\\s</td>
    <td>Symbols which appear white (do not render). Includes spaces, tabs, newlines,
        and unicode line/paragraph separators and page feeds.</td>
  </tr>
  <tr>
    <td colspan="2"><a name="nonwhite">Non-white</a></td>
    <td>\\S</td>
    <td>Symbols which do not match the criteria for whitespace characters. Includes
        letters, digits, control characters, and any symbolic unicode glyphs.</td>
  </tr>
</table>

<h1 id="valtypes">Value Types<a href="#toc" class="backlink">Back to Top</a></h1>
In URBAN, many operands accept numeric values. URBAN legend does not distinguish types of
expressions which may be passed to each operand. Instead, the distinction is made at the
instruction/directive level between which instructions can accept what in their expressions.

<table>
  <tr>
    <th>Abbr</th>
    <th>Expression Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td id="literal">literal</td>
    <td>Literals</td>
    <td>Literals are constants which are not encapsulated under an identifier name.
  </tr>
  <tr>
    <td class="stripebg" rowspan="2"></td>
    <td>Numeric Literal</td>
    <td>Numeric literals are denoted exclusively using the numerals 0-9.</td>
  </tr>
  <tr>
    <td>String Literal</td>
    <td>String literals are collections of characters given in single quotes, such
        as 'hello, world!'. See <a href="#strlit">strlit</a>.</td>
  </tr>
  <tr>
    <td id="const">const</td>
    <td>Constant expression</td>
    <td>Constant expressions may contain arithmetic between <a href="#literal">literals</a> and between
        previously defined labels; ie, forward references and external references are prohibited.
        Star notation and address references to previous labels are both allowed. The assembler must
        be able to evaluate a constant expression for its final, pre-link value upon reading it.<br/>
        <i>Using a const expression in a non-const field will allow the linker to adjust its value.</i></td>
  </tr>
  <tr>
    <td id="expr">expr</td>
    <td>Expression</td>
    <td>Expressions can be constant expressions, but can also use forward referencing and incorporate
        external addresses via <a href="#exlabel">exlabels</a>.</td>
  </tr>
</table>

Fields in this specification will refer to several types of value types and ranges.

<table>
  <tr>
    <th>Abbr</th>
    <th>Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td id="longlit">longlit</td>
    <td><b>Long</b> <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the complete URBAN word, (-2<sup>31</sup>)
        to (2<sup>31</sup>-1).</td>
  </tr>
  <tr>
    <td id="ilit">ilit</td>
    <td><b>I</b>nline <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the standard instruction format literal, (-2<sup>16</sup>)
        to (2<sup>16</sup>-1).</td>
  </tr>
  <tr>
    <td id="mlit">mlit</td>
    <td><b>M</b>emory <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the URBAN memory, 0 to 4095.</td>
  </tr>
  <tr>
    <td id="smlit">smlit</td>
    <td><b>S</b>igned <b>M</b>emory <b>Lit</b>eral</td>
    <td>A literal or expression in two's compliment form which takes the same space as an address;
        ie, a number in range -2048 to 2047.</td>
  </tr>
  <tr>
    <td id="bclit">bclit</td>
    <td><b>B</b>it <b>C</b>ount <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the URBAN word bit count, 0 to 31.</td>
  </tr>
  <tr>
    <td id="strlit">strlit</td>
    <td><b>Str</b>ing <b>Lit</b>eral</td>
    <td>A string literal, denoted in single quotes, with or without escape sequences.</td>
  </tr>
</table>

<h1 id="addrstat">Address Status Flags <a href="#toc" class="backlink">Back to Top</a></h1>
<table>
	<tr>
		<th colspan="3">Flag</th>
		<th>Name</th>
		<th>Description</th>
	</tr>
	<tr>
		<td colspan="3">'A'</td>
		<td>Absolute</td>
		<td>Value is not modified by linker.</td>
	</tr>
	<tr>
		<td colspan="3">'E'</td>
		<td>External</td>
		<td>Address is an external reference..</td>
	</tr>	
	<tr>
		<td colspan="3">'R'</td>
		<td>Relative/Relocatable</td>
		<td>Address is relative to program address so it is adjusted by offset.</td>
	</tr>	
	<tr>
		<td colspan="3">'C'</td>
		<td>Absolute</td>
		<td>Multiple addresses in instruction that do not mathematically cancel out.</td>
	</tr>	
	<tr>
		<td colspan="3">'N'</td>
		<td>Negate</td>
		<td>Negate entire value.</td>
	</tr>
</table>
<h1 id="directivespec">Directive Specifications <a href="#toc" class="backlink">Back to Top</a></h1>
<p>The following table gives the syntax for each directive and their format along with it.</p>

<table>
  <tr>
    <th colspan="2">Specification</th>
    <th>Syntax Element</th>
    <th>Details</th>
  </tr>
  <tr>
    <td colspan="2"><a name="DS1">DS1</a></td>
    <td>Label</td>
    <td>Different directives have different label requirements.</td>
  </tr>
  <tr>
    <td rowspan="3" class="stripebg"></td><td>DS1.1</td>
    <td><a name="rqlabel">rqlabel</a></td>
    <td><b>R</b>e<b>q</b>uired <b>label</b>: A label must appear here.</td>
  </tr>
  <tr>
    <td>DS1.2</td>
    <td><a name="nolabel">none</a></td>
    <td>A label can not appear here, or a syntax error will be produced.</td>
  </tr>
  <tr>
    <td>DS1.3</td>
    <td><a name="olabel">olabel</a></td>
    <td><b>O</b>ptional <b>label</b>: A label can be given, but is not required.</td>
  </tr>
  <tr>
    <td colspan="2">DS2</td>
    <td>Directive name</td>
    <td>Can begin the line or follow a label. Read in according to label syntax rules as specified
        in <a href="#DS1">DS1</a>, but expected to be a string of case-unspecific letters. Must
        match an instruction from the <a href="#instructions">instruction table.</a></td>
  </tr>
  <tr>
    <td colspan="2">DS3</td>
    <td>Operands</td>
    <td>Operands are given after the instruction and are denoted by <a href="#keywords">keywords</a>.
        Each operand clause must begin with one such keyword, followed by a colon and any number of whitespace
        characters. Operand values are read from the first non-white character after the colon to the nearest
        comma or semicolon thereafter. A comma separates operands, denoting that another follows, while a semicolon
        denotes the end of the operand list and end of the instruction. Different instructions accept
        different combinations of operands.</td>
  </tr>
  <tr>
    <td rowspan="8" class="stripebg"><td>DS3.1</td>
    <td id="number">number</td>
    <td>A signed two's compliment number, in range (-2<sup>16</sup>) to (2<sup>16</sup>-1).</td>
  </tr>
  <tr>
    <td id="DS3.2">DS3.2</td>
    <td id="rlabel">rlabel</td>
    <td><b>R</b>elative <b>label</b>; a label within the current program.</td>
  </tr>
  <tr>
    <td id="DS3.3">DS3.3</td>
    <td id="eqlabel">eqlabel</td>
    <td>Label equated to a value in the appropriate range, as denoted in <a href="#valtypes">Value Types</a>.</td>
  </tr>
  <tr>
    <td id="DS3.4">DS3.4</td>
    <td id="nlabel">nlabel</td>
    <td>A label reference of any sort (<a href="#rlabel">rlabel</a>, <a href="#eqlabel">eqlabel</a>,
        <a href="#exlabel">exlabel</a>), or a <a href="#number">number</a>.</td>
  </tr>
  <tr>
    <td id="DS3.5">DS3.5</td>
    <td id="exabel">exlabel</td>
    <td>string of 1 to 32 characters and numbers meeting syntax rules 
        for a label. Representing a reference to a label in a totally 
        different module</td>
  </tr>
  <tr>
    <td id="DS3.6">DS3.6</td>
    <td>memr</td>
    <td>Obsolete synonym for <a href="#mlit">mlit</a>.</td>
  </tr>
  <tr>
    <td id="DS3.8">DS3.8</td>
    <td id="expression">expression</td>
    <td>An expression meeting the rules laid forth in <a href="#valtypes">Value Types</a>.</td>
  </tr>
  <tr>
    <td id="DS3.9">DS3.9</td>
    <td>Star</td>
    <td>Star notation is allowed in expressions; see <a href="#valtypes">Value Types</a>.
    </td>
  </tr>
</table>

<h1 id="syntax">Syntax Specifications <a href="#toc" class="backlink">Back to Top</a></h1>
<p>
  The basic syntax for URBAN is as follows: <br/>
  <tt>
    <span style="font-style:italic;color:#800080;">label</span>
    <span style="font-weight:bold;color:#000080;">instruction</span>
    <span style="color:#0000ff;">Keyword1</span><span style="color:#ff0000;">:</span><span style="color:#00e1af;">operand1</span><span style="color:#ff0000;">,</span>
    <span style="color:#0000ff;">Keyword2</span><span style="color:#ff0000;">:</span><span style="color:#00e1af;">operand2</span><span style="color:#ff0000;">;</span>
    <span style="font-style:italic;color:#a5a5a5;"> Comments </span>
  </tt>
</p>

<table>
  <tr>
    <th colspan="4">Specification</th>
    <th>Feature</th>
    <th>Requirements</th>
  </tr>
  <tr>
    <td colspan="4">S1</td>
    <td>Instructions</td>
    <td>All instructions are composed of two to four <a href="#letter">letters</a>.
        Instructions are matched in a case-insensitive manner.</td>
  </tr>
  <tr>
    <td colspan="4">S2</td>
    <td>Instruction Syntax</td>
    <td>Input sent to the assembler must follow all syntax rules as presented in this document.<br/>
        The assembler shall verify that the input it receives is valid and report syntax errors as needed.</td>
  </tr>
  <tr>
    <td rowspan="16" class="stripebg"></td>
    <td colspan="3">S2.1</td>
    <td>Labels</td>
    <td>Labels in URBAN are denoted by a letter followed by up to 31 additional
        <a href="#nonwhite">non-white</a> characters. These characters can be
        anything except <a href="controlchar">control characters</a>. Labels
        cannot match <a href="#instructions">instruction names</a>.</td>
  </tr>
  <tr>
    <td colspan="3">S2.2</td>
    <td>Numbers</td>
    <td>The numbers in instructions are integers in the range 0-4095</td>
  </tr>
  <tr>
    <td colspan="3">S2.3</td>
    <td>Characters</td>
    <td>Items that can be enter directly through the keyboard with in
    a single stroke or while holding down the shift key are characters.</td>
  </tr>
  <tr>
    <td colspan="3">S2.4</td>
    <td>Instructions</td>
    <td>All the instructions are alphabetical characters.An instruction can be a mixed case.</td>
  </tr>
  <tr>
    <td colspan="3">S2.5</td>
    <td>Operands</td>
    <td>Operands are alphabetical or numeric. The operand field 
    is keyword driven. Commas separate their values followed by zero or
    more blanks. A semicolon terminates the operand fieldThe list of
    operand kwywords is given <a href="#keywords">below</a>.</td>
  </tr>
  <tr>
    <td rowspan="11" class="stripebg"></td>
    <td colspan="2">S2.5.1</td>
    <td>Arithmetic Register Specification</td>
    <td>The Arithmetic Register field references the arithmetic registers 0 to 7. The field can also contain a previously equated label in the same range.</td>
  </tr>
  <tr>
    <td colspan="2">S2.5.2</td>
    <td>Memory Reference</td>
    <td>Memory referencing is allowed through several mechanisms.</td>
  </tr>
  <tr>
    <td rowspan="9" class="stripebg"></td>
    <td>S2.5.2.1</td>
    <td>rlabel</td>
    <td>See <a href="#DS3.2">DS3.2</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.2</td>
    <td>exlabel</td>
    <td>See <a href="#DS3.5">DS3.5</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.3</td>
    <td>nlabel</td>
    <td>See <a href="#DS3.4">DS3.4</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.4</td>
    <td>indirect</td>
    <td>Planned feature.</td>
  </tr>
  <tr>
    <td>S2.5.2.5</td>
    <td>direct</td>
    <td>By default, referencing in URBAN is direct.</td>
  </tr>
  <tr>
    <td>S2.5.2.6</td>
    <td>eqlabel</td>
    <td>A label representing a preprocessed (equated) constant.</td>
  </tr>
  <tr>
    <td>S2.5.2.7</td>
    <td id="literals">Literal/Immediate</td>
    <td>Instructions which take source addresses may be given a literal instead.
        The value will be embedded in the instruction in the same location the
        address would otherwise appear.</td>
  </tr>
  <tr>
    <td>S2.5.2.8</td>
    <td>Constants</td>
    <td>Constants can be used in a number of instructions, including those which support a
        source memory address (see <a href="#literals">Literals</a> for more information</a>).
        Constants can be expressions meeting the rules in <a href="#valtypes">Value Types</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.9</td>
    <td>Star (<tt>*</tt>)</td>
    <td>The asterisk, or star symbol, may be used in a constant expression to denote the
        value of the current location counter. This value can also be used in arithmetic.</td>
  </tr>
  <tr>
    <td colspan="4">S3.0</td>
    <td>End of Instruction</td>
    <td>The semicolon (<tt>;</tt>) denotes the end of an instruction.</td>
  </tr>
  <tr>
    <td colspan="4">S4.0</td>
    <td>Comments</td>
    <td>Comments may be given after the end of an instruction (ie, after a semicolon).
        They are terminated at the end of the line. A semicolon may begin a line to denote
        a full line of comments.</td>
  </tr>
  <tr>
    <td class="stripebg"></td>
    <td colspan="3">S4.1</td>
    <td>Full Line of Comments</td>
    <td>A line of comment begins with a semicolon(;) in column 1. This line is MUST be printed on the assembly user report</td>
  </tr>
  <tr>
    <td colspan="4">S5.0</td>
    <td>Field separators</td>
    <td>One or more blanks or tabs that is between label and opcode seperator. Also between keywords the separator is a single comma</td>
  </tr>
</table>


<h1 id="directives">Directives<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
There are 12 directives in the URBAN language.They are given in the following table along with their format and descriptions.
</p>


<table>
  <tr>
    <th>Spec</th>
    <th>Directive</th>
    <th width="20%">Format</th>
    <th>Description</th>
    <th>Impacts LC</th>
  </tr>
  <tr>
    <td>D1</td>
    <td id="d_kicko">KICKO</td>
    <td><a href="#rqlabel">rqlabel</a> kicko  FC:<a href="#mlit">mlit</a>;</td>
    <td><b>"Kick off"</b> the program from the address specified in FC. 
        The label given to the directive serves as the program name.
        The KickO directive must appear on the first line of the file.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D2</td>
    <td id="d_">newlc</td>
    <td><a href="#rqlabel">rqlabel</a> newlc FC:<a href="#mlit">mlit</a>;<br/>
        <a href="#rqlabel">rqlabel</a> newlc LR:<a href="#eqlabel">eqlabel</a>;</td>
    <td>Sets a <b>new</b> relocatable address to the <b>L</b>ocation <b>C</b>ounter. 
        Multiple newlc directives can appear in one program.</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D3</td>
    <td id="d_">EQU</td>
    <td><a href="#rqlabel">rqlabel</a>  equ  FC:<a href="#mlit">mlit</a>;<br/>
        <a href="#rqlabel">rqlabel</a>  equ  LR:<a href="#eqlabel">eqlabel</a>;</td>
    <td>Equate the label of this directive to the operand of FC or LR. Any labels used in
        those expressions must have been previously equated. Expressions and star notation are allowed.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D4</td>
    <td id="d_">EQUe</td>
    <td><a href="#rqlabel">rqlabel</a> eque ex:<a href="#expression">expression</a>;</td>
    <td><b>Equ</b>ated <b>E</b>xpression. Added for compatibility with other URBAN assemblers;
        originally intended to be similar to EQU but support EX expressions. EQU supports both.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D5</td>
    <td id="d_">ENT</td>
    <td><a href="#nolabel">none</a> ENT LR:<a href="#rlabel">rlabel</a>, ...;<br/>
    <i>Multiple operands supported</i></td>
    <td><b>Ent</b>ry point name: denotes to the linker that local labels given in LR operands
        can be referenced in other programs if declared with <a href="#EXT">EXT</a>.
        As such, each LR operand generates a Linking Record in the object file.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D6</td>
    <td id="d_">EXT</td>
    <td><a href="#nolabel">none</a> EXT LR:<a href="#exlabel">exlabel</a>, ...;<br/>
    <i>Multiple operands supported</i></td>
    <td>EXTernal variable name: declares the label and denotes to the linker that it will be in
        another file. Labels given to LR must not appear in this program, or they will be shadowed.
        The declared label must be declared ENT in another program against which the current program
        will be linked.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D7</td>
    <td id="d_">END</td>
    <td><a href="#nolabel">none</a> end LR:label;</td>
    <td>Denotes <b>end</b> of source; confirms to the assembler that all input has been processed.
        Lines of code after this directive will generate a warning. As a CRC, the label passed to
        LR must match the rlabel given to <a href="#d_kicko">KickO</a>.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D8</td>
    <td id="d_aexs">AEXS</td>
    <td><a href="#olabel">olabel</a> AEXS LR:<a href="#rlabel">rlabel</a>;<br/>
        <a href="#olabel">olabel</a> AEXS FC:<a href="#mlit">mlit</a>;</td>
    <td><b>A</b>lternative <b>Ex</b>ecution <b>S</b>tart: Changes the start address of this program
        to the relocatable address specified in the FC operand, or that of the label specified to
        the LR operand.</td>
    <td></td>
  </tr>
  <tr>
    <td>D9</td>
    <td id="d_skips">SKIPS</td>
    <td><a href="#olabel">olabel</a> SKIPS FC:<a href="#mlit">mlit</a>;</td>
    <td><b>Skip S</b>torage: Allocates space for the number of words specified in the FC operand.
        These words will be left as raw memory for use by the program. They will be zeroed at load.</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D10</td>
    <td id="d_char">CHAR</td>
    <td><a href="#olabel">olabel</a> CHAR ST:<a href="#strlit">strlit</a>;</td>
    <td><b>Char</b>acter Constant: Reserves a sufficient number of words to store the string literal
        given to ST, and packs them into memory. Unused bytes will be padded with blanks (0x20).</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D11</td>
    <td id="d_num">NUM</td>
    <td><a href="#olabel">olabel</a> num FC:<a href="#longlit">longlit</a>;</td>
    <td>Base 10 <b>num</b>ber in the range (-2<sup>31</sup>) to (2<sup>31</sup>-1).</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D12</td>
    <td id="d_adrc">ADRC</td>
    <td><a href="#olabel">olabel</a> adrc LR:<a href="#rlabel">rlabel</a>;<br/>
        <a href="#olabel">olabel</a> adrc LR:<a href="#exlabel">exlabel</a>;<br/>
        <a href="#olabel">olabel</a> adrc EX:<a href="#expression">expression</a>;</td>
    <td><b>Ad</b>d<b>r</b>ess <b>C</b>onstant. Included for compatibility with other URBAN
        assemblers. ADRC is not required to do complex expressions in URBAN Legend.</td>
    <td>Yes</td>
  </tr>
</table>
<p>


<h1 id="keywords">Operand Keywords<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
  To simplify format memorization, URBAN uses keywords rather than order to disambiguate
  operands to each instruction or directive.
</p><p>
  Different instructions support different operands, and different operands can be represented
  by different keywords. Some operands specify a source kind, others a destination kind. For
  instance, if an instruction takes a source and destination, keywords can be used to specify
  that the source will be a memory address while the destination is to be a register.
</p><p>
  The table below lists keywords and their unabbreviated names.
</p>


<table>
  <tr>
    <th>Keyword</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>DM</td>
    <td><b>D</b>estination <b>M</b>emory</td>
  </tr> 
  <tr>
    <td>DR</td>
    <td><b>D</b>estination <b>R</b>egister</td>
  </tr>
  <tr>
    <td>DX</td>
    <td><b>D</b>estination inde<b>x</b> Register</td>
  </tr>
  <tr>
    <td>EX</td>
    <td><b>Ex</b>pression</td>
  </tr>
  <tr>
    <td>FC</td>
    <td><b>F</b>rom <b>C</b>onstant</td>
  </tr>
  <tr>
    <td>FL</td>
    <td><b>F</b>rom <b>L</b>iteral</td>
  </tr>
  <tr>
    <td>FM</td>
    <td><b>F</b>rom <b>M</b>emory</td>
  </tr>
  <tr>
    <td>FR</td>
    <td><b>F</b>rom <b>R</b>egister</td>
  </tr>
  <tr>
    <td>FX</td>
    <td><b>F</b>rom inde<b>x</b> Register</td>
  </tr>
  <tr>
    <td>LR</td>
    <td><b>L</b>abel <b>R</b>eference</td>
  </tr>
  <tr>
    <td>NW</td>
    <td><b>N</b>umber of <b>W</b>ords</td>
    </tr>
  <tr>
    <td>ST</td>
    <td><b>St</b>ring Literal</td>
  </tr>
</table>

<p> It is valid, but discouraged, to use directive names as labels. </p>

<h1 id="instructions">Instructions<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
The following tables describe the various instructions with their formats and their binary equivalent opcodes.
</p>


<table>
<tr><th>Spec Key   </th><th colspan="2"> Instruction Name                                               </th><th> Opcode </th><th> Valid Operand Combos                                                                                                                                                           </th><th> Special Ranges                           </th><th> Instruction Formats Used        </th><th> Description                                                                                                                                                             </th></tr>
<tr><td>MVO        </td><td> MOVD  </td><td>(<b>Mov</b>e <b>D</b>ata)                                   </td><td> 000000 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Moves data from a register to memory loc or memory loc to a register or register to register                                                                            </td></tr>
<tr><td>MV1        </td><td> MOVDN </td><td>(<b>Mov</b>e <b>D</b>ata and <b>N</b>egate)                 </td><td> 000001 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Moves data from a register-1 to memory lco or memory loc -1 to a register or register-1 to register                                                                     </td></tr>
<tr><td>IA0        </td><td> IADD  </td><td>(<b>I</b>nteger <b>Add</b>)                                 </td><td> 001000 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Adds memory loc and a register together or a register and a register                                                                                                    </td></tr>
<tr><td>IA1        </td><td> IMAD  </td><td>(<b>I</b>nteger <b>M</b>ultiply and <b>Ad</b>d)             </td><td> 001001 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Multiplys memory loc or register with a register or memory loc and adds memory loc or register to total                                                                 </td></tr>
<tr><td>IA2        </td><td> IAA   </td><td>(<b>I</b>nteger <b>A</b>dd <b>A</b>bsolute)                 </td><td> 001010 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Adds absolute value of memory loc to a register or absolute value register to memory loc or absolute register to register                                               </td></tr>
<tr><td>IA3        </td><td> ISRG  </td><td>(<b>I</b>nteger <b>S</b>um <b>R</b>ang<b>e</b>)             </td><td> 001011 </td><td> {NW,FM,DR},{NW,FM,DX}                                                                                                                                                          </td><td> FL,EX:[-4096,4095]                       </td><td> Dest-Range                      </td><td> Sums all the numbers from mref to mref+NW                                                                                                                               </td></tr>
<tr><td>IA4        </td><td> ISUB  </td><td>(<b>I</b>nteger <b>Sub</b>traction)                         </td><td> 001100 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Subtracts memory loc and a register together or a register and another register                                                                                         </td></tr>
<tr><td>IA5        </td><td> IMUL  </td><td>(<b>I</b>nteger <b>Mul</b>tiplication)                      </td><td> 001101 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Mulitplys memory loc and a register together or a register and another register                                                                                         </td></tr>
<tr><td>IA6        </td><td> IDIV  </td><td>(<b>I</b>nteger <b>Div</b>ision)                            </td><td> 001110 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Divides memory loc and a register together or a register and anotherregister                                                                                            </td></tr>
<tr><td>IA7        </td><td> PWR   </td><td>(<b>P</b>o<b>w</b>e<b>r</b>)                                </td><td> 001111 </td><td> {DX,FC},{DR,FC},{DX,EX},{DR,EX}                                                                                                                                                </td><td> FC,EX:[-32768,32767]                     </td><td> Literal                         </td><td> Computes the value of a register to a certain power                                                                                                                     </td></tr>
<tr><td>IS0        </td><td> CLR   </td><td>(<b>Cl</b>ear <b>r</b>egister)                              </td><td> 010000 </td><td> {DR},{DX}                                                                                                                                                                      </td><td>                                          </td><td> Memory                          </td><td> clear an index or arithmetic register.                                                                                                                                  </td></tr>
<tr><td>IS1        </td><td> CLRA  </td><td>(<b>Cl</b>ear <b>a</b>rithmetic <b>r</b>egisters)           </td><td> 010001 </td><td> {}                                                                                                                                                                             </td><td>                                          </td><td> OP Only                         </td><td> clears all arithmetic registers.                                                                                                                                        </td></tr>
<tr><td>IS2        </td><td> CLRX  </td><td>(<b>Cl</b>ear Inde<b>x R</b>egisters)                       </td><td> 010010 </td><td> {}                                                                                                                                                                             </td><td>                                          </td><td> OP Only                         </td><td> clears all index registers.                                                                                                                                             </td></tr>
<tr><td>IM0        </td><td> ISHR  </td><td>(<b>I</b>nteger <b>Sh</b>ift <b>R</b>ight logical)          </td><td> 011000 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC,EX:[0,31]                             </td><td> Literal                         </td><td> shifts the right given constant bits and fills all the shifted bits with 0's                                                                                            </td></tr>
<tr><td>IM1        </td><td> ISHL  </td><td>(<b>I</b>nteger <b>Sh</b>ift <b>L</b>eft logical)           </td><td> 011001 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC,EX:[0,31]                             </td><td> Literal                         </td><td> shifts the left given constant bits and fills all the shifted bits with 0's                                                                                             </td></tr>
<tr><td>IM2        </td><td> ISRA  </td><td>(<b>I</b>nteger <b>S</b>hift <b>R</b>ight <b>a</b>rithmetic)</td><td> 011010 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC,EX:[0,31]                             </td><td> Literal                         </td><td> shifts the right given constant bits and fills all the shifted bits with the sign bit                                                                                   </td></tr>
<tr><td>IM3        </td><td> ISLA  </td><td>(<b>I</b>nteger <b>S</b>hift <b>L</b>eft  <b>a</b>rithmetic)</td><td> 011011 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC,EX:[0,31]                             </td><td> Literal                         </td><td> shifts the left given constant bits and fills all the shifted bits with the sign bit                                                                                    </td></tr>
<tr><td>IM4        </td><td> ROL   </td><td>(<b>Ro</b>tate <b>L</b>eft)                                 </td><td> 011100 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC,EX:[0,31]                             </td><td> Literal                         </td><td> rotates left, including the sign bit                                                                                                                                    </td></tr>
<tr><td>IM5        </td><td> ROR   </td><td>(<b>Ro</b>tate <b>R</b>ight)                                </td><td> 011101 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC,EX:[0,31]                             </td><td> Literal                         </td><td> rotates right, including the sign bit                                                                                                                                   </td></tr>
<tr><td>IM6        </td><td> AND   </td><td>(Logical <b>AND</b>)                                        </td><td> 011110 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Ands a memory loc and a register together or a register and another register                                                                                            </td></tr>
<tr><td>IM7        </td><td> OR    </td><td>(Logical <b>OR</b>)                                         </td><td> 011111 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> Mem,Lit,Mem + Mem,Mem + Lit     </td><td> Ors a memory loc and a register together or a register and another register                                                                                             </td></tr>
<tr><td>JT0        </td><td> TREQ  </td><td>(<b>Tr</b>ansfer if <b>Eq</b>ual to Zero)                   </td><td> 100000 </td><td> {FR,DM},{FR,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> Memory                          </td><td> if contents of register = 0, then jump to address given.                                                                                                                </td></tr>
<tr><td>JT1        </td><td> TRLT  </td><td>(<b>Tr</b>ansfer if <b>L</b>ess <b>T</b>han Zero)           </td><td> 100001 </td><td> {FR,DM},{FR,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> Memory                          </td><td> if contents of register < 0, then jump to address given.                                                                                                                </td></tr>
<tr><td>JT2        </td><td> TRGT  </td><td>(<b>Tr</b>ansfer if <b>G</b>reater <b>t</b>han Zero)        </td><td> 100010 </td><td> {FR,DM},{FR,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> Memory                          </td><td> if contents of register > 0, then jump to address given.                                                                                                                </td></tr>
<tr><td>JT3        </td><td> TR    </td><td>(<b>Tr</b>ansfer Unconditionally)                           </td><td> 100011 </td><td> {DM},{DM,DX}                                                                                                                                                                   </td><td>                                          </td><td> Memory                          </td><td> Jumps to address given.                                                                                                                                                 </td></tr>
<tr><td>JT4        </td><td> TRDR  </td><td>(<b>Tr</b>ansfer or <b>D</b>ecrement <b>R</b>egister)       </td><td> 100100 </td><td> {FR,DM},{FR,DM,DX},{FX,DM},{FX,DM,DX}                                                                                                                                          </td><td>                                          </td><td> Memory                          </td><td> Decrements contents of register, and if decremented register = 0, jumps to address given.                                                                                                             </td></tr>
<tr><td>JT5        </td><td> TRLK  </td><td>(<b>Tr</b>ansfer and <b>L</b>ink)                           </td><td> 100101 </td><td> {DM,DR},{DM,DX,DR}                                                                                                                                                             </td><td>                                          </td><td> Memory                          </td><td> The Return address of the instruction is stored in register, and the instruction jumps to address given.                                                                </td></tr>
<tr><td>JT6        </td><td> RET   </td><td>(<b>Ret</b>urn to Calling Program)                          </td><td> 100110 </td><td> {DM},{DM,DX},{DR}                                                                                                                                                              </td><td>                                          </td><td> Memory                          </td><td> Jumps to address given; can take a register.                                                                                                                                                 </td></tr>
<tr><td>JT7        </td><td> SKT   </td><td>(<b>S</b>tac<b>k</b> <b>T</b>est)                           </td><td> 100111 </td><td> {DR}                                                                                                                                                                           </td><td>                                          </td><td> Memory                          </td><td> Register given is set to size of stack.                                                                                                                                 </td></tr>
<tr><td>IO0        </td><td> IWSR  </td><td>(<b>I</b>nteger   <b>W</b>rite to <b>S</b>c<b>r</b>een)     </td><td> 101000 </td><td> {NW,FM,FX},{NW,FM},{NW,FL},{NW,EX}                                                                                                                                             </td><td> FL,EX:[-4096,4095]                       </td><td> Source-Range                    </td><td> outputs an integer to screen from memory.                                                                                                                               </td></tr>
<tr><td>IO2        </td><td> CWSR  </td><td>(<b>C</b>haracter <b>W</b>rite to <b>S</b>c<b>r</b>een)     </td><td> 101010 </td><td> {NW,FM,FX},{NW,FM},{NW,FL},{NW,EX}                                                                                                                                             </td><td> FL,EX:[-4096,4095]                       </td><td> Source-Range                    </td><td> outputs a character to screen from memory.                                                                                                                              </td></tr>
<tr><td>IO1        </td><td> IRKB  </td><td>(<b>I</b>nteger   <b>R</b>ead from <b>K</b>ey<b>b</b>oard)  </td><td> 101001 </td><td> {NW,DM},{NW,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> Dest-Range                      </td><td> inputs an integer from keyboard to memory.                                                                                                                              </td></tr>
<tr><td>IO3        </td><td> CRKB  </td><td>(<b>C</b>haracter <b>R</b>ead from <b>K</b>ey<b>b</b>oard)  </td><td> 101100 </td><td> {NW,DM},{NW,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> Dest-Range                      </td><td> inputs a character from keyboard to memory.                                                                                                                             </td></tr>
<tr><td>S0         </td><td> PSH   </td><td>(<b>P</b>u<b>sh</b>)                                        </td><td> 110000 </td><td> {FC},{FL},{EX},{FM}                                                                                                                                                            </td><td> FL,FC,EX:[-4096,4095]                    </td><td> Memory,Literal                  </td><td> pushes the memory element onto the top of the stack                                                                                                                     </td></tr>
<tr><td>S1         </td><td> POP   </td><td>(<b>Pop</b>)                                                </td><td> 110001 </td><td> {DR},{DM}                                                                                                                                                                      </td><td>                                          </td><td> Memory,Literal                  </td><td> pops the top stack element into memory or register.                                                                                                                     </td></tr>
<tr><td>S2         </td><td> PST   </td><td>(<b>P</b>op and Te<b>st</b>)                                </td><td> 110010 </td><td> {FM,DR},{FM,FX,DR},{FL,DR},{EX,DR}                                                                                                                                             </td><td> FL,EX:[-4096,4095]                       </td><td> Memory,Literal                  </td><td> pops the top stack element, and compares the element with memory or literal: if = then load DR with 0; if < load DR with 2; if > load DR with 3.  </td></tr>
<tr><td>C0         </td><td> NOP   </td><td>(<b>N</b>on-<b>op</b>erative)                               </td><td> 111101 </td><td> {}                                                                                                                                                                             </td><td>                                          </td><td> OP Only                         </td><td> no operation.                                                                                                                                                           </td></tr>
<tr><td>C2         </td><td> HLT   </td><td>(<b>H</b>a<b>lt</b>)                                        </td><td> 111110 </td><td> {FC},{EX}                                                                                                                                                                      </td><td> FC:[-4096, 4095]                         </td><td> Halt/Dump                       </td><td> halts the program, and displays the constant to screen.                                                                                                                 </td></tr>
<tr><td>C1         </td><td> DMP   </td><td>(<b>D</b>u<b>mp</b>)                                        </td><td> 111111 </td><td> {FC},{EX}                                                                                                                                                                      </td><td> FC:[1,3]                                 </td><td> Halt/Dump                       </td><td> displays register and memory contents to screen.  if fc = 1, then level 1 dump; if fc = 2, then level 2 dump; if fc = 3, then level 3 dump.                             </td></tr>
</table>

The following instructions are unique to URBAN Legend:
<table>
<tr><th>Key</th><th>Name</th><th>Abbr</th><th>Opcode</th><th>Combinations</th></th><th>Special Ranges</th><th>Instruction Formats Used</th></tr>
<tr><td rowspan="2" class="stripebg">UL1</td><td> SND   </td><td>(<b>S</b>ou<b>nd</b>) </td><td> 000100 </td><td>{ST,FR,DM}</td><td>FR:[50,20000], FR:[25,6400]</td>
    <td><span style="color:red" title="opcode">000100</span><span style="color:green" title="type">0000</span><span style="color:blue" title="Frequency">00000000000000</span><span style="color:purple" title="Duration">00000000</span></td>
    </tr><tr><td colspan="6"> Outputs a sound to any attached speaker. This requires re-intepretation of the pre-defined URBAN 
         keywords. The new interpretations are as follow:
         <ul><li>ST: <span style="color:green"><b>S</b>ample <b>T</b>ype</span>. A case-insensitive string containing any of the sample names below.</li>
             <li>FR: <span style="color:blue"><b>Fr</b>equency</span>. The frequency of the note to play, between 50 and 20,000 (Roughly the range of human hearing)</li>
             <li>DM: <span style="color:purple"><b>D</b>uration in <b>M</b>illiseconds</span>. Between 25 and 6400 milliseconds; must be a multiple of 25 or it will be rounded as such.</li>
         </ul>
         
         <table>
		<tr><th>white</th>           <td>White noise. Largely unaffected by frequency.</td>    <th>hihat</th>           <td ROWSPAN="2">A highhat sample.</td>                    </tr>
		<tr><th>square</th>          <td>A square wave with the given frequency.</td>          <th>hat</th>                                                                       </tr>
		<tr><th>saw</th>             <td>A saw wave with the given frequency.</td>             <th>distortedkick</th>   <td ROWSPAN="2">A distorted kick drum sample.</td>        </tr>
		<tr><th>sine</th>            <td>A sine wave with the given frequency.</td>            <th>dkick</th>                                                                     </tr>
		<tr><th>pluck</th>           <td>A guitar pluck generated at the given frequency.</td> <th>kickdrum</th>        <td ROWSPAN="2">A kick drum sample.</td>                  </tr>
		<tr><th>boink</th>           <td>The TF2 BOINK! sample.</td>                           <th>kick</th>                                                                      </tr>
		<tr><th>bonk</th>            <td>The TF2 BONK! sample.</td>                            <th>snaredrum</th>       <td ROWSPAN="2">A snare drum sample.</td>                 </tr>
		<tr><th>bassdrum</th>        <td ROWSPAN="2">A bass drum sample.</td>                  <th>snare</th>                                                                     </tr>
		<tr><th>bass</th>                                                                      <th>tomtomdrum</th>      <td ROWSPAN="3">A tomtom drum sample.</td>                </tr>
		<tr><th>cowbell</th>         <td>A cowbell sample.</td>                                <th>tomtom</th>                                                                    </tr>
		<tr><th>cymbal</th>          <td>A cymbol sample.</td>                                 <th>tom</th>                                                                       </tr>
		<tr><th>distortedsnare</th>  <td ROWSPAN="2">A distorted snare drum sample.</td>       <td COLSPAN="2" ROWSPAN="2" class="stripebg"></td>                                 </tr>
		<tr><th>dsnare</th>                                                                                                                                                       </tr>
	</table>
    </td>
</td></tr>
<tr><td rowspan="2" class="stripebg">UL2</td><td> SLP </td><td>(<b>Sl</b>ee<b>p</b>)</td><td> 111011 </td><td>{FC}</td><td></td>
    <td>Literal</td>
    </tr><tr><td colspan="6"> Suspends the current thread for the given number of milliseconds.
    </td>
</td></tr>
<tr><td rowspan="2" class="stripebg">UL3</td><td> FORK </td><td>(<b>Fork</b>) </td><td> 111100 </td><td>{DM}, {DM,DX}</td><td></td>
    <td>Memory</td>
    </tr><tr><td colspan="6"> Forks the machine, similar to the UNIX standard. 
       Memory and registers are shared between all forks; only thelocation counter
       can vary between them. The FORK instruction does not modify the calling thread's
       location counter (it is simply incremented). Instead, the counter of the new
       thread is placed at the given address (shifted by the content of any given index
       register).
    </td>
</td></tr>
<tr><td rowspan="2" class="stripebg">UL4</td><td> PRINTF </td><td>(<b>Print F</b>ormatted Data) </td><td> 111000 </td><td>{FM}, {FM,FX}, {FM,NW}, {FM,FX,NW}, {ST}</td><td></td>
    <td>Source-Range</td>
    </tr><tr><td colspan="6"> <p>Similar to the C function printf(), PRINTF prints a string in the following format:</p>
      <p style="color:blue">"%0 bottles of beer on the wall, %0 bottles of beer!"</p>
      </p>
      <p>The percent sign (%) is used to denote the value of a register. Similarly, the dollar sign ($) is used to denote
         the value of an index register. Placing two of either symbol in a row will produce the symbol itself.</p>
      <p>If the format string is specified to this instruction using ST, no other information is required.</p>
      <p>If the string is specified, a word count may be given. If a number of words is specified, it is used as in the
         CWSR instruction. Otherwise, the string must be explicitly null-terminated by the programmer using \0.</p>
    </td>
</td></tr>
</table>

<h1 id="objfile">Object File Specification<a href="#toc" class="backlink">Back to Top</a></h1>

Object files exported by URBAN-Legend contain chunks according to the following specification.

<table>
  <tr>
    <th colspan="4">Spec Ref</th>
    <th width="15%">Format</th>
    <th>Description</th>
  </tr>
  <tr>
    <td colspan="4" id="OB1">OB1</td>
    <td>Header Record</td>
    <td>Appears only once, at the beginning of the object file.</td>
  </tr>
    <tr>
      <td rowspan="17" class="stripebg"></td>
      <td colspan="3" id="OB1.1">OB1.1</td>
      <td>Byte('H')</td>
      <td>Header record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.2">OB1.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.3">OB1.3</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.4">OB1.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.5">OB1.5</td>
      <td>Short, HHHH</td>
      <td>Assembler Assigned Program Load Address (4 hex nybbles)</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.6">OB1.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.7">OB1.7</td>
      <td>Long, HHHH</td>
      <td>Total Module Length (0 to 03FF)</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.8">OB1.8</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.9">OB1.9</td>
      <td>Long, HHHH</td>
      <td>Execution Start Address (0 to 03FF)</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.10">OB1.10</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.11">OB1.11</td>
      <td>yearda,hh:mm:ss</td>
      <td>Date and Time of Assembly. Example Jan 3, 2011 3AM would be 2011003,03:00:00 </td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.12">OB1.12</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.13">OB1.13</td>
      <td>4 digit Integer value</td>
      <td>Version Number of Assembler</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.14">OB1.14</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.15">OB1.15</td>
      <td>9 character String</td>
      <td>URBAN-ASM </td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.16">OB1.16</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB1.17">OB1.17</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name, same as <a href="#OB1.3">OB1.3</a></td>
    </tr>
  <tr>
    <td colspan="4" id="OB2">OB2</td>
    <td>Linking Record</td>
    <td>Created for each entry point into the program.</td>
  </tr>
    <tr>
      <td rowspan="7" class="stripebg"></td>
      <td colspan="3" id="OB2.1">OB2.1</td>
      <td>Byte('L')</td>
      <td>Linking record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB2.2">OB2.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB2.3">OB2.3</td>
      <td>LABEL, 1-32 Bytes</td>
      <td>Entry Label</td>
    </tr>
    <tr>
      <td colspan="3" id="OB2.4">OB2.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB2.5">OB2.5</td>
      <td>Short, HHHH</td>
      <td>Entry Address (4 hex nybbles)</td>
    </tr>
    <tr>
      <td colspan="3" id="OB2.6">OB2.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB2.7">OB2.7</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name, same as <a href="#OB1.3">OB1.3</a></td>
    </tr>
  <tr>
    <td colspan="4" id="OB3">OB3</td>
    <td>Text Record</td>
    <td>Created for each instruction or directive in the program.</td>
  </tr>
    <tr>
      <td rowspan="15" class="stripebg"></td>
      <td colspan="3" id="OB3.1">OB3.1</td>
      <td>Byte('T')</td>
      <td>Text record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.2">OB3.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.3">OB3.3</td>
      <td>Short, HHHH</td>
      <td>Entry Address (4 hex nybbles),program assigned location</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.4">OB3.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.5">OB3.5</td>
      <td>8N</td>
      <td>Assembled instruction/data word in 8N digit hex code</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.6">OB3.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.7">OB3.7</td>
      <td>A, R, E, or C</td>
      <td>Address status flag for high-order bits</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.8">OB3.8</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.9">OB3.9</td>
      <td>A, R, E, or C</td>
      <td>Address status flag for low-order bits</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.10">OB3.10</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.11">OB3.11</td>
      <td>1 digit hex number</td>
      <td>Number of modifications of high-order bits</td>
    </tr>
    <tr>
      <td colspan="3" id="OB3.12">OB3.12</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
        <td colspan="3" id="OB3.13">OB3.13</td>
        <td>1 digit hex number</td>
        <td>Number of modifications of low-order bits</td>
    </tr>
       <tr>
        <td colspan="3" id="OB3.14">OB3.14</td>
        <td>Byte(':')</td>
        <td>Standard separator</td>
    </tr>
    <tr>
        <td colspan="3" id="OB3.15">OB3.15</td>
        <td>LABEL, 1-32 bytes</td>
        <td>Program Name, same as <a href="#OB1.3">OB1.3</a></td>
    </tr>
  <tr>
    <td colspan="4" id="OB4">OB4</td>
    <td>Modification Record</td>
    <td>Created for each data field in the instruction assembly which requires any link-time adjustment.</td> 
  </tr>
    <tr>
      <td rowspan="16" class="stripebg"></td>
      <td colspan="3" id="OB4.1">OB4.1</td>
      <td>Byte('M')</td>
      <td>Modification record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.2">OB4.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.3">OB4.3</td>
      <td>Short, HHHH</td>
      <td>Four hex nybbles</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.4">OB4.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.5">OB4.5</td>
      <td>CHUNK</td>
      <td>Adjustment Chunk: One per link-time adjustment</td>
    </tr>
       <tr>
         <td rowspan="6" class="stripebg"></td>
         <td colspan="2" id="OB4.5.1">OB4.5.1</td>
         <td>Byte('+' or '-')</td>
         <td>The sign of this adjustment; a '+' indicates that the adjustment is added, a '-' denotes that
         it is instead subtracted.</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.2">OB4.5.2</td>
         <td>Byte(':')</td>
         <td>Standard separator</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.3">OB4.5.3</td>
         <td>Byte('R' or 'E')</td>
         <td>Address type flag of the label that needs adjustment.</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.4">OB4.5.4</td>
         <td>Byte(':')</td>
         <td>Standard separator</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.5">OB4.5.5</td>
         <td>LABEL, 1-32 Bytes</td>
         <td>The label whose address the linker will use to adjust this record</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.6">OB4.5.6</td>
         <td>Byte(':')</td>
         <td>Standard separator</td>
       </tr>
    <tr>
      <td colspan="3" id="OB4.6">OB4.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.7">OB4.7</td>
      <td>Byte('H' or 'L' or 'S')</td>
      <td>High- or Low-order Address. 'H' if bits 9-20 are to be considered, 'L' 
          if bits 20-32 are to be considered, 'S' if this was a Single-address
          instruction.</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.8">OB4.8</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.9">OB4.9</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name, same as <a href="#OB1.3">OB1.3</a></td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.10">OB4.10</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
  <tr>
    <td colspan="4" id="OB5">OB5</td>
    <td>End Record</td>
    <td>Appears only once, as the last record in the file.</td>
  </tr>
    <tr>
      <td rowspan="11" class="stripebg"></td>
      <td colspan="3" id="OB5.1">OB5.1</td>
      <td>Byte('E')</td>
      <td>End record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.2">OB5.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.3">OB5.3</td>
      <td>Short, HHHH</td>
      <td>total Number of Records</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.4">OB5.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.5">OB5.5</td>
      <td>Short, HHHH</td>
      <td>Total Number of Linking records</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.6">OB5.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.7">OB5.7</td>
      <td>Short, HHHH</td>
      <td>Total Number of Text records</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.8">OB5.8</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.9">OB5.9</td>
      <td>Short, HHHH</td>
      <td>Total Number of Modification records</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.10">OB5.10</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.11">OB5.11</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name, same as <a href="#OB1.3">OB1.3</a></td>
    </tr>
</table>

<h1 id="loadfile">Load File Specification<a href="#toc" class="backlink">Back to Top</a></h1>

Loader files exported by URBAN-Legend contain chunks according to the following specification.

<table>
  <tr>
    <th colspan="4">Spec Ref</th>
    <th width="15%">Format</th>
    <th>Description</th>
  </tr>
  <tr>
    <td colspan="4" id="LM1">LM1</td>
    <td>Header Record</td>
    <td>Appears only once, at the beginning of the Load file.</td>
  </tr>
    <tr>
      <td rowspan="18" class="stripebg"></td>
      <td colspan="3" id="LM1.1">LM1.1</td>
      <td>Byte('H')</td>
      <td>Header record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.2">LM1.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.3">LM1.3</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Module name from the first object file</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.4">LM1.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.5">LM1.5</td>
      <td>Short, HHHH</td>
      <td>Combined Module Load Address.</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.6">LM1.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.7">LM1.7</td>
      <td>Long, HHHH</td>
      <td>Module Execution Start Address.</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.8">LM1.8</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.9">LM1.9</td>
      <td>Long, HHHH</td>
      <td>Total length of the Module</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.10">LM1.10</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.11">LM1.11</td>
      <td>yearda,hh:mm:ss</td>
      <td>Date and Time of Assembly. Example Jan 7, 2011 10AM would be 2011007,10:00:00 </td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.12">LM1.12</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.13">LM1.13</td>
      <td>9 character String</td>
      <td>URBAN-LLM</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.14">LM1.14</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.15">LM1.15</td>
      <td>4 didgit Number</td>
      <td>Version Number #</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.16">LM1.16</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM1.17">LM1.17</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name from the First Object File</td>
    </tr>	
	<tr>
      <td colspan="3" id="LM1.18">LM1.18</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
	  <tr>
		<td colspan="4" id="LM2">LM2</td>
		<td>Text Record</td>
		<td>Created for each entry point into the program.</td>
	  </tr>
		<tr>
		  <td rowspan="8" class="stripebg"></td>
		  <td colspan="3" id="LM2.1">LM2.1</td>
		  <td>Byte('T')</td>
		  <td>Text record indicator</td>
		</tr>
		<tr>
		  <td colspan="3" id="LM2.2">LM2.2</td>
		  <td>Byte(':')</td>
		  <td>Standard separator</td>
		</tr>
		<tr>
		  <td colspan="3" id="LM2.3">LM2.3</td>
		  <td>6 didgit Hex, HHHHHH</td>
		  <td>Program Assigned Location(6 hex nibbles)</td>
		</tr>
		<tr>
		  <td colspan="3" id="LM2.4">LM2.4</td>
		  <td>Byte(':')</td>
		  <td>Standard separator</td>
		</tr>
		<tr>
		  <td colspan="3" id="LM2.5">LM2.5</td>
		  <td>8 digit Hex HHHH HHHH</td>
		  <td>Instruction/ Data in Text Record (8 hex nybbles)</td>
		</tr>
		<tr>
		  <td colspan="3" id="LM2.6">LM2.6</td>
		  <td>Byte(':')</td>
		  <td>Standard separator</td>
		</tr>
		<tr>
		  <td colspan="3" id="LM2.7">LM2.7</td>
		  <td>LABEL, 1-32 bytes</td>
		  <td>Program Name, same as <a href="#LM1.17">LM1.17</a></td>
		</tr>
		<tr>
        <td colspan="3" id="LM2.8">LM2.8</td>
          <td>Byte(':')</td>
		  <td>Standard separator</td>
		</tr>
	<tr>
    <td colspan="4" id="OB5">OB5</td>
    <td>End Record</td>
    <td>Appears only once, as the last record in the file.</td>
  </tr>
    <tr>
      <td rowspan="8" class="stripebg"></td>
      <td colspan="3" id="OB5.1">OB5.1</td>
      <td>Byte('E')</td>
      <td>End record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM5.2">LM5.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM5.3">LM5.3</td>
      <td>Short, HHHH</td>
      <td>Total Number of Records</td>
    </tr>
    <tr>
      <td colspan="3" id="LM5.4">LM5.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="LM5.5">LM5.5</td>
      <td>Short, HHHH</td>
      <td>Total Number of Text records</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.6">OB5.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB5.7">OB5.7</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name, same as <a href="#LM1.17">LM1.17</a></td>
    </tr>
	<tr>
      <td colspan="3" id="LM5.8">LM5.8</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
</table>

<h1 id="sampleio">URBAN Legend Input and Output Description and Format<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
<h5>URBAN Legend Input:</h5>
        Enter program in GUI as described in the \ref stepByStep.
</p>
 
<h5>URBAN Legend output format:</h5>
"URBAN Legend" followed by version number.
e.g. URBAN Legend v1

"Usage: java -jar urban.jar file1 file2 file3... -o executablename" <br>

"Assembling " followed by file paths of files to assemble. <br>
e.g. Assembling C:\\Users\\User/Desktop/test.s <br>
<p> 
"Symbol Table:" followed by the symbol table. <br>
each line of symbol table displays: label address usage equString <br>
label is the label of the instruction in the symbol table. <br>
address is the instruction's address. <br>
usage is one of the following: <br>
    <pre>
        LABEL, PROGNAME, EXTERNAL, EQUATE, or ENTRY.
         LABEL is when the label is used as a label.
         PROGNAME is when the label is used as a module name.
         EXTERNAL is when the label is used as an external label.
         EQUATE is when the label is being equated to the equString.
         ENTRY is when the label is used as an entry label.
    </pre>
equString is only used by instructions with the EQUATE usage.
       It is what the label is being equated to. <br>
</p>
<p> 
"Instruction breakdowns:" followed by a list of the breakdowns of each instruction in the module. <br>
each instruction breakdown is as follows: <br>
        <pre>
        LC	Object Code	Address Status	Line Num	Source Line
		(hex)	(hex)	src:, dest:	     (dec)
		errors:
        </pre>
</p>
<p>       
        Source Line is the original source line that the assembler parsed. <br>
        lineNum is the line number in the source file that the source line appeared in decimal. <br>
        Address Status is the address status of the instruction. source address status follows src: and destination address follows dest:. If no address status is applicable, then display '-'.<br>
        Object Code is the assembled hexadecimal code of the instruction if there is one.  If there is not, "------" is displayed.<br>
        LC is the address of the instruction in hexadecimal.<br>
  
        if there are less than 4 operands, however many operands there are in the instruction are displayed. 
        errors is a list of errors separated by new line.<br>
</p>
</p> 
<p>
<a href="#toc">Back to Menu</a>
</p> 

*/
