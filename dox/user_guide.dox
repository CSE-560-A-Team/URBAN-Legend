/*!
\page userguide User Guide

<p>
This is a user guide that describe the specifications for the URBAN - Universal Robust Binary Assembler-Nator.
There are 4096 words (32 bits each) of location counter relative addressable memory that is available to a user.
We used Java as the language for constructing this while using Eclipse as an IDE.
The exact specifications of this language can be seen below.
</p>
<h1 id="toc">Table of contents</h1>
<ol>
  <li><a href="#hardware">Hardware Specifications</a></li>
  <li><a href="#instructionspec">Instruction Specifications</a></li>
  <li><a href="#symbols">Symbol Classifications </a></li>
  <li><a href="#valtypes">Value Types</a></li>
  <li><a href="#directivespec">Directive Specifications </a></li>
  <li><a href="#syntax">Syntax Specifications </a></li>
  <li><a href="#keywords">Operand Keywords</a></li>
  <li><a href="#directives">Directives</a></li>
  <li><a href="#instructions">Instructions</a></li>
  <li><a href="#sampleio">URBAN Legend Input and Output Description and Format</a></li>
</ol>

<h1 id="hardware">Hardware Specifications<a href="#toc" class="backlink">Back to Top</a></h1>
<p>The table below illustrates the Hardware specifications of the URBAN machine.</p>

<table>
<tr>
  <th colspan="2">Specification</th>
  <th>Hardware Item</th>
  <th>Details</th>
</tr>
<tr>
  <td colspan="2">H1</td>
  <td>Processor</td>
  <td>The URBAN machine incorporates a 10.2 GHz Meyer 1.0 CPU, implemented using
      600-picometer technology with a liquid-helium-based cooling system.</td>
</tr>
<tr>
  <td colspan="2">H2</td>
  <td>Word Size</td>
  <td>The URBAN architecture uses 32-bit words.</td>
</tr>
<tr>
  <td colspan="2">H2</td>
  <td>Memory</td>
  <td>Memory in the URBAN architecture is word addressable and is guaranteed to be
      4096 words in size. Memory uses 16 micrometer technology and is passively
      cooled; at least 20,000 clock cycles are required per read, plus sync time.
      Addresses are 12 bits, ranging from 0 to 4095 (FFF<sub>16</sub>).</td>
</tr>
<tr>
  <td colspan="2">H3</td>
  <td>Registers</td>
  <td>The URBAN machine contains a total of 15 registers.</td>
</tr>
<tr>
  <td rowspan="2" class="stripebg"></td><td width="48">H3.1</td>
  <td>Arithmetic Registers</td>
  <td>Of the 15, eight are reserved for use with arithmetic.</td>
</tr>
<tr>
  <td width="48">H3.2</td>
  <td>Indexed Registers</td>
  <td>Of the fifteen, seven may be used to alter an address in certain instructions.</td>
</tr>
 
<tr>
  <td colspan="2">H4</td>
  <td>Arithmetic Unit</td>
  <td>Literals in the URBAN architecture are represented using two's compliment format.
      Addresses and registers are represented in unsigned format.</td>
</tr>
<tr>
  <td colspan="2">H5</td>
  <td>Internal Representations</td>
  <td>Internally, all values are stored as words (32 bit).</td>
</tr>
<tr>
  <td rowspan="2" class="stripebg"></td><td width="32">H5.1</td>
  <td>Numbers</td>
  <td>When representing a number, the high-order bit serves as a sign bit. By specification H4,
      the range for all numbers is therefore (-2<sup>32</sup>) to (2<sup>32</sup>-1).</td>
</tr>
<tr>
  <td width="32">H5.2</td>
  <td>Characters</td>
  <td>When representing strings of characters, UTF-8 encoding is used, and the word is interpreted as a
      string of four 8-bit UTF-8 characters.</td>
</tr>
<tr>
  <td colspan="2">H6</td>
  <td>Addressing</td>
  <td>As stated in specification H2, memory in the the URBAN machine is <i>word</i> addressable, <b>not</b> byte addressable.</td>
</tr>
</table>


<h1 id="instructionspec">Instruction Specifications<a href="#toc" class="backlink">Back to Top</a></h1>
<p>Instructions in the URBAN language follow the same basic format:</p>

<p>
<span style="color:#ff0000"><b>OPCODE</b></span>(6b),
<span style="color:#ff6600"><b>FORMAT</b></span>(1b),
<span style="color:#009900"><b>IS_LITERAL</b></span>(1b),
<span style="color:#339999"><b>SOURCE</b></span>,
<span style="color:#3333ff"><b>DESTINATION</b></span>,
<span style="color:#cc33cc"><b>DATA</b></span>(16b).
</p>

<p>This structure allows for easy hand-assembly, as the only nybble sharing is between the opcode and format. For example, <tt>MOVD FR:1, DR:2;</tt> assembles to 
<span style="color:#ff0000">0</span><span style="color:#ff6600">0</span><span style="color:#339999">1</span><span style="color:#3333ff">2</span><span style="color:#cc33cc">0000</span>.</p>

The <span style="color:#339999"><b>SOURCE</b></span> and
<span style="color:#3333ff"><b>DESTINATION</b></span> nybbles
are identical; they are laid out as a single bit representing 
the type of the item followed by three bits for the register number.<br>

<ul>
  <li><b>0</b> <i>000</i> - <b>0</b> <i>111</i> Are arithmetic registers 0 - 7, as specified in H3.1.</li>
  <li><b>1</b> <i>001</i> - <b>1</b> <i>111</i> Are index registers, 1 - 7, as specified in H3.2.</li>
  <li><b>1</b> <i>000</i> Is an invalid index register, and is used to indicate that the <span style="color:#cc33cc"><b>DATA</b></span> member is used.</li>
</ul>

<p>The <span style="color:#cc33cc"><b>DATA</b></span> field is sixteen
bits, and is only used as described in the points above. If the 
<span style="color:#009900"><b>IS_LITERAL</b></span> bit is set, all sixteen bits of the
<span style="color:#cc33cc"><b>DATA</b></span> member are used as the literal,
and the value can range from -32768 to 32767 as per specification H4. If the 
<span style="color:#009900"><b>IS_LITERAL</b></span> bit is not set, then the
<span style="color:#cc33cc"><b>DATA</b></span> member is broken into an indexed
address; the first nybble gives the index register, or zero for none, and the next
three nybbles denote the address. Should the size of the memory for the machine grow,
a bit can be removed from the first nybble and given to the second.</p>

An illustration of the breakdown of these formats is given in the two following tables:
<table>
  <tr>
    <th>Format</th>
    <td colspan="6"><span style="color:#ff0000"><b>OPCODE</b></span>       </td>
    <td colspan="1"><span style="color:#ff6600"><b>FORMAT</b></span>       </td>
    <td colspan="1"><span style="color:#009900"><b>IS_LITERAL</b></span>   </td>
    <td colspan="4"><span style="color:#339999"><b>SOURCE</b></span>       </td>
    <td colspan="4"><span style="color:#3333ff"><b>DESTINATION</b></span>  </td>
    <td colspan="16"><span style="color:#cc33cc"><b>DATA</b></span>        </td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Memory</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="4"><b>IXR</b></td>
    <td colspan="12"><b>Memory address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>1</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Literal</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="16"><b>Literal</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>1</b></td>
    <td>1</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">DEST-Range</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="4"><b><i>Word Count</i></b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="4"><b>IXR</b></td>
    <td colspan="12"><b>Memory address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>0</td><td>0</td><td>0</td><td>1</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">SRC-Range</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="1"><b>Index?</b></td>
    <td colspan="3"><b>Register</b></td>
    <td colspan="4"><b><i>Word Count</i></b></td>
    <td colspan="4"><b>IXR</b></td>
    <td colspan="12"><b>Memory address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>1</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>1</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">OP-Literal</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="16"><b>Literal</b></td>
  </tr>
  <tr>
    <td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td>
    <td><b>0</b></td><td><b>1</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">OP Only</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Unused</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="4"><b>Unused</b></td>
    <td colspan="16"><b>Unused</b></td>
  </tr>
  <tr>
    <td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>0</b></td><td><b>0</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
</table>

<br/>

<p>When the format bit is set, the source and destination expand to consume the entire 3-byte remainder, as shown:</p>
<table>
  <tr>
    <th>Format</th>
    <td colspan="6"> <span style="color:#ff0000"><b>OPCODE</b></span>       </td>
    <td colspan="1"> <span style="color:#ff6600"><b>FORMAT</b></span>       </td>
    <td colspan="1"> <span style="color:#009900"><b>IS_LITERAL</b></span>   </td>
    <td colspan="12"><span style="color:#339999"><b>SOURCE</b></span>       </td>
    <td colspan="12"><span style="color:#3333ff"><b>DESTINATION</b></span>  </td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Memory + Memory</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="12"><b>Address 1</b></td>
    <td colspan="12"><b>Address 2</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>1</b></td><td><b>0</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
  <tr style="background:#DAE0FF">
    <th rowspan="2">Literal + Memory</th>
    <td colspan="6"><b>OP Code</b></td>
    <td colspan="2"><b>Format</b></td>
    <td colspan="12"><b>Literal</b></td>
    <td colspan="12"><b>Address</b></td>
  </tr>
  <tr>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td><b>1</b></td><td><b>1</b></td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
    <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
  </tr>
</table>

Combinations that can not be used in the above formats include the following:<br>
<ul>
  <li>Indexed memory with memory: FM,DM,DX; <i>or</i> FM,FX,DM<br></li>
  <li>Indexed memory with indexed memory: FM,FX,DM,DX;</li>
  <li>Literal and indexed memory: FL,DM,DX;</li>
  <li>Dual-destination transfers: FR,DR,DX; <i>or</i> FM,DR,DX<br></li>
</ul>

<h1 id="symbols">Symbol Classifications <a href="#toc" class="backlink">Back to Top</a></h1>
<table>
  <tr>
    <th colspan="2">Classification</th>
    <th>RegExp</th>
    <th>Description</th>
  </tr>
  <tr>
    <td colspan="2"><a name="letter">Letter</a></td>
    <td>[a-zA-Z_]</td>
    <td>The ASCII characters 'a'-'z' and 'A'-'Z', and the underscore character '_'.
  </tr>
  <tr>
    <td colspan="2"><a name="letter">Digit</a></td>
    <td>[0-9]</td>
    <td>Decimal digits for use as integer literals.</td>
  </tr>
  <tr>
    <td colspan="2"><a name="controlchar">Control Character</a></td>
    <td>[;:,+-\\*\\/]</td><td>Symbols carrying syntactical meaning as operators or separators.</td>
    </tr><tr><td rowspan="7" class="stripebg">
    </td>    <td>;</td><td>;</td><td>Semicolons are used to separate instructions and begin comments.</td>
    </tr><tr><td>:</td><td>:</td><td>Colons are used to denote the start of an operand's value.</td>
    </tr><tr><td>,</td><td>,</td><td>Commas are used to separate individual operands to the same instruction.</td>
    </tr><tr><td>+</td><td>\\+</td><td>The plus symbol denotes addition; it can only be used in operand expressions.</td>
    </tr><tr><td>-</td><td>-</td><td>The minus symbol denotes addition; it can only be used in operand expressions.</td>
    </tr><tr><td>*</td><td>\\*</td><td>The asterisk (*) denotes the current location counter in operand expressions.</td>
    </tr><tr><td>/</td><td>\\/</td><td>The division symbol (/) is reserved for future use.</td>
  </tr>
  <tr>
    <td colspan="2"><a name="white">Whitespace</a></td>
    <td>\\s</td>
    <td>Symbols which appear white (do not render). Includes spaces, tabs, newlines,
        and unicode line/paragraph separators and page feeds.</td>
  </tr>
  <tr>
    <td colspan="2"><a name="nonwhite">Non-white</a></td>
    <td>\\S</td>
    <td>Symbols which do not match the criteria for whitespace characters. Includes
        letters, digits, control characters, and any symbolic unicode glyphs.</td>
  </tr>
</table>

<h1 id="valtypes">Value Types<a href="#toc" class="backlink">Back to Top</a></h1>
In URBAN, many operands accept numeric values. URBAN legend does not distinguish types of
expressions which may be passed to each operand. Instead, the distinction is made at the
instruction/directive level between which instructions can accept what in their expressions.

<table>
  <tr>
    <th>Abbr</th>
    <th>Expression Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td id="literal">literal</td>
    <td>Literals</td>
    <td>Literals are constants which are not encapsulated under an identifier name.
  </tr>
  <tr>
    <td class="stripebg" rowspan="2"></td>
    <td>Numeric Literal</td>
    <td>Numeric literals are denoted exclusively using the numerals 0-9.</td>
  </tr>
  <tr>
    <td>String Literal</td>
    <td>String literals are collections of characters given in single quotes, such
        as 'hello, world!'. See <a href="#strlit">strlit</a>.</td>
  </tr>
  <tr>
    <td id="const">const</td>
    <td>Constant expression</td>
    <td>Constant expressions may contain arithmetic between <a href="#literal">literals</a> and between
        previously defined labels; ie, forward references and external references are prohibited.
        Star notation and address references to previous labels are both allowed. The assembler must
        be able to evaluate a constant expression for its final, pre-link value upon reading it.<br/>
        <i>Using a const expression in a non-const field will allow the linker to adjust its value.</i></td>
  </tr>
  <tr>
    <td id="expr">expr</td>
    <td>Expression</td>
    <td>Expressions can be constant expressions, but can also use forward referencing and incorporate
        external addresses via <a href="#exlabel">exlabels</a>.</td>
  </tr>
</table>

Fields in this specification will refer to several types of value types and ranges.

<table>
  <tr>
    <th>Abbr</th>
    <th>Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td id="longlit">longlit</td>
    <td><b>Long</b> <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the complete URBAN word, (-2<sup>31</sup>)
        to (2<sup>31</sup>-1).</td>
  </tr>
  <tr>
    <td id="ilit">ilit</td>
    <td><b>I</b>nline <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the standard instruction format literal, (-2<sup>16</sup>)
        to (2<sup>16</sup>-1).</td>
  </tr>
  <tr>
    <td id="mlit">mlit</td>
    <td><b>M</b>emory <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the URBAN memory, 0 to 4095.</td>
  </tr>
  <tr>
    <td id="smlit">smlit</td>
    <td><b>S</b>igned <b>M</b>emory <b>Lit</b>eral</td>
    <td>A literal or expression in two's compliment form which takes the same space as an address;
        ie, a number in range -2048 to 2047.</td>
  </tr>
  <tr>
    <td id="bclit">bclit</td>
    <td><b>B</b>it <b>C</b>ount <b>Lit</b>eral</td>
    <td>A literal or expression in the range of the URBAN word bit count, 0 to 31.</td>
  </tr>
  <tr>
    <td id="strlit">strlit</td>
    <td><b>Str</b>ing <b>Lit</b>eral</td>
    <td>A string literal, denoted in single quotes, with or without escape sequences.</td>
  </tr>
</table>

<h1 id="directivespec">Directive Specifications <a href="#toc" class="backlink">Back to Top</a></h1>
<p>The following table gives the syntax for each directive and their format along with it.</p>

<table>
  <tr>
    <th colspan="2">Specification</th>
    <th>Syntax Element</th>
    <th>Details</th>
  </tr>
  <tr>
    <td colspan="2"><a name="DS1">DS1</a></td>
    <td>Label</td>
    <td>Different directives have different label requirements.</td>
  </tr>
  <tr>
    <td rowspan="3" class="stripebg"></td><td>DS1.1</td>
    <td><a name="rqlabel">rqlabel</a></td>
    <td><b>R</b>e<b>q</b>uired <b>label</b>: A label must appear here.</td>
  </tr>
  <tr>
    <td>DS1.2</td>
    <td><a name="nolabel">none</a></td>
    <td>A label can not appear here, or a syntax error will be produced.</td>
  </tr>
  <tr>
    <td>DS1.3</td>
    <td><a name="olabel">olabel</a></td>
    <td><b>O</b>ptional <b>label</b>: A label can be given, but is not required.</td>
  </tr>
  <tr>
    <td colspan="2">DS2</td>
    <td>Directive name</td>
    <td>Can begin the line or follow a label. Read in according to label syntax rules as specified
        in <a href="#DS1">DS1</a>, but expected to be a string of case-unspecific letters. Must
        match an instruction from the <a href="#instructions">instruction table.</a></td>
  </tr>
  <tr>
    <td colspan="2">DS3</td>
    <td>Operands</td>
    <td>Operands are given after the instruction and are denoted by <a href="#keywords">keywords</a>.
        Each operand clause must begin with one such keyword, followed by a colon and any number of whitespace
        characters. Operand values are read from the first non-white character after the colon to the nearest
        comma or semicolon thereafter. A comma separates operands, denoting that another follows, while a semicolon
        denotes the end of the operand list and end of the instruction. Different instructions accept
        different combinations of operands.</td>
  </tr>
  <tr>
    <td rowspan="8" class="stripebg"><td>DS3.1</td>
    <td id="number">number</td>
    <td>A signed two's compliment number, in range (-2<sup>16</sup>) to (2<sup>16</sup>-1).</td>
  </tr>
  <tr>
    <td id="DS3.2">DS3.2</td>
    <td id="rlabel">rlabel</td>
    <td><b>R</b>elative <b>label</b>; a label within the current program.</td>
  </tr>
  <tr>
    <td id="DS3.3">DS3.3</td>
    <td id="eqlabel">eqlabel</td>
    <td>Label equated to a value in the appropriate range, as denoted in <a href="#valtypes">Value Types</a>.</td>
  </tr>
  <tr>
    <td id="DS3.4">DS3.4</td>
    <td id="nlabel">nlabel</td>
    <td>A label reference of any sort (<a href="#rlabel">rlabel</a>, <a href="#eqlabel">eqlabel</a>,
        <a href="#exlabel">exlabel</a>), or a <a href="#number">number</a>.</td>
  </tr>
  <tr>
    <td id="DS3.5">DS3.5</td>
    <td id="exabel">exlabel</td>
    <td>string of 1 to 32 characters and numbers meeting syntax rules 
        for a label. Representing a reference to a label in a totally 
        different module</td>
  </tr>
  <tr>
    <td id="DS3.6">DS3.6</td>
    <td>memr</td>
    <td>Obsolete synonym for <a href="#mlit">mlit</a>.</td>
  </tr>
  <tr>
    <td id="DS3.8">DS3.8</td>
    <td id="expression">expression</td>
    <td>An expression meeting the rules laid forth in <a href="#valtypes">Value Types</a>.</td>
  </tr>
  <tr>
    <td id="DS3.9">DS3.9</td>
    <td>Star</td>
    <td>Star notation is allowed in expressions; see <a href="#valtypes">Value Types</a>.
    </td>
  </tr>
</table>

<h1 id="syntax">Syntax Specifications <a href="#toc" class="backlink">Back to Top</a></h1>
<p>
  The basic syntax for URBAN is as follows: <br/>
  <tt>
    <span style="font-style:italic;color:#800080;">label</span>
    <span style="font-weight:bold;color:#000080;">instruction</span>
    <span style="color:#0000ff;">Keyword1</span><span style="color:#ff0000;">:</span><span style="color:#00e1af;">operand1</span><span style="color:#ff0000;">,</span>
    <span style="color:#0000ff;">Keyword2</span><span style="color:#ff0000;">:</span><span style="color:#00e1af;">operand2</span><span style="color:#ff0000;">;</span>
    <span style="font-style:italic;color:#a5a5a5;"> Comments </span>
  </tt>
</p>

<table>
  <tr>
    <th colspan="4">Specification</th>
    <th>Feature</th>
    <th>Requirements</th>
  </tr>
  <tr>
    <td colspan="4">S1</td>
    <td>Instructions</td>
    <td>All instructions are composed of two to four <a href="#letter">letters</a>.
        Instructions are matched in a case-insensitive manner.</td>
  </tr>
  <tr>
    <td colspan="4">S2</td>
    <td>Instruction Syntax</td>
    <td>Input sent to the assembler must follow all syntax rules as presented in this document.<br/>
        The assembler shall verify that the input it receives is valid and report syntax errors as needed.</td>
  </tr>
  <tr>
    <td rowspan="16" class="stripebg"></td>
    <td colspan="3">S2.1</td>
    <td>Labels</td>
    <td>Labels in URBAN are denoted by a letter followed by up to 31 additional
        <a href="#nonwhite">non-white</a> characters. These characters can be
        anything except <a href="controlchar">control characters</a>. Labels
        cannot match <a href="#instructions">instruction names</a>.</td>
  </tr>
  <tr>
    <td colspan="3">S2.2</td>
    <td>Numbers</td>
    <td>The numbers in instructions are integers in the range 0-4095</td>
  </tr>
  <tr>
    <td colspan="3">S2.3</td>
    <td>Characters</td>
    <td>Items that can be enter directly through the keyboard with in
    a single stroke or while holding down the shift key are characters.</td>
  </tr>
  <tr>
    <td colspan="3">S2.4</td>
    <td>Instructions</td>
    <td>All the instructions are alphabetical characters.An instruction can be a mixed case.</td>
  </tr>
  <tr>
    <td colspan="3">S2.5</td>
    <td>Operands</td>
    <td>Operands are alphabetical or numeric. The operand field 
    is keyword driven. Commas separate their values followed by zero or
    more blanks. A semicolon terminates the operand fieldThe list of
    operand kwywords is given <a href="#keywords">below</a>.</td>
  </tr>
  <tr>
    <td rowspan="11" class="stripebg"></td>
    <td colspan="2">S2.5.1</td>
    <td>Arithmetic Register Specification</td>
    <td>The Arithmetic Register field references the arithmetic registers 0 to 7. The field can also contain a previously equated label in the same range.</td>
  </tr>
  <tr>
    <td colspan="2">S2.5.2</td>
    <td>Memory Reference</td>
    <td>Memory referencing is allowed through several mechanisms.</td>
  </tr>
  <tr>
    <td rowspan="9" class="stripebg"></td>
    <td>S2.5.2.1</td>
    <td>rlabel</td>
    <td>See <a href="#DS3.2">DS3.2</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.2</td>
    <td>exlabel</td>
    <td>See <a href="#DS3.5">DS3.5</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.3</td>
    <td>nlabel</td>
    <td>See <a href="#DS3.4">DS3.4</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.4</td>
    <td>indirect</td>
    <td>Planned feature.</td>
  </tr>
  <tr>
    <td>S2.5.2.5</td>
    <td>direct</td>
    <td>By default, referencing in URBAN is direct.</td>
  </tr>
  <tr>
    <td>S2.5.2.6</td>
    <td>eqlabel</td>
    <td>A label representing a preprocessed (equated) constant.</td>
  </tr>
  <tr>
    <td>S2.5.2.7</td>
    <td id="literals">Literal/Immediate</td>
    <td>Instructions which take source addresses may be given a literal instead.
        The value will be embedded in the instruction in the same location the
        address would otherwise appear.</td>
  </tr>
  <tr>
    <td>S2.5.2.8</td>
    <td>Constants</td>
    <td>Constants can be used in a number of instructions, including those which support a
        source memory address (see <a href="#literals">Literals</a> for more information</a>).
        Constants can be expressions meeting the rules in <a href="#valtypes">Value Types</a>.</td>
  </tr>
  <tr>
    <td>S2.5.2.9</td>
    <td>Star (<tt>*</tt>)</td>
    <td>The asterisk, or star symbol, may be used in a constant expression to denote the
        value of the current location counter. This value can also be used in arithmetic.</td>
  </tr>
  <tr>
    <td colspan="4">S3.0</td>
    <td>End of Instruction</td>
    <td>The semicolon (<tt>;</tt>) denotes the end of an instruction.</td>
  </tr>
  <tr>
    <td colspan="4">S4.0</td>
    <td>Comments</td>
    <td>Comments may be given after the end of an instruction (ie, after a semicolon).
        They are terminated at the end of the line. A semicolon may begin a line to denote
        a full line of comments.</td>
  </tr>
  <tr>
    <td class="stripebg"></td>
    <td colspan="3">S4.1</td>
    <td>Full Line of Comments</td>
    <td>A line of comment begins with a semicolon(;) in column 1. This line is MUST be printed on the assembly user report</td>
  </tr>
  <tr>
    <td colspan="4">S5.0</td>
    <td>Field separators</td>
    <td>One or more blanks or tabs that is between label and opcode seperator. Also between keywords the separator is a single comma</td>
  </tr>
</table>


<h1 id="directives">Directives<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
There are 12 directives in the URBAN language.They are given in the following table along with their format and descriptions.
</p>


<table>
  <tr>
    <th>Spec</th>
    <th>Directive</th>
    <th width="20%">Format</th>
    <th>Description</th>
    <th>Impacts LC</th>
  </tr>
  <tr>
    <td>D1</td>
    <td id="d_kicko">KICKO</td>
    <td><a href="#rqlabel">rqlabel</a> kicko  FC:<a href="#mlit">mlit</a>;</td>
    <td><b>"Kick off"</b> the program from the address specified in FC. 
        The label given to the directive serves as the program name.
        The KickO directive must appear on the first line of the file.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D2</td>
    <td id="d_">newlc</td>
    <td><a href="#rqlabel">rqlabel</a> newlc FC:<a href="#mlit">mlit</a>;<br/>
        <a href="#rqlabel">rqlabel</a> newlc LR:<a href="#eqlabel">eqlabel</a>;</td>
    <td>Sets a <b>new</b> relocatable address to the <b>L</b>ocation <b>C</b>ounter. 
        Multiple newlc directives can appear in one program. Each newlc generates a
        Linking record in the object file, but does not generate bitcode.</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D3</td>
    <td id="d_">EQU</td>
    <td><a href="#rqlabel">rqlabel</a>  equ  FC:<a href="#mlit">mlit</a>;<br/>
        <a href="#rqlabel">rqlabel</a>  equ  LR:<a href="#eqlabel">eqlabel</a>;</td>
    <td>Equate the label of this directive to the operand of FC or LR. Any labels used in
        those expressions must have been previously equated. Expressions and star notation are allowed.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D4</td>
    <td id="d_">EQUe</td>
    <td><a href="#rqlabel">rqlabel</a> eque ex:<a href="#expression">expression</a>;</td>
    <td><b>Equ</b>ated <b>E</b>xpression. Added for compatibility with other URBAN assemblers;
        originally intended to be similar to EQU but support EX expressions. EQU supports both.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D5</td>
    <td id="d_">ENT</td>
    <td><a href="#nolabel">none</a> ENT LR:<a href="#rlabel">rlabel</a>, ...;<br/>
    <i>Multiple operands supported</i></td>
    <td><b>Ent</b>ry point name: denotes to the linker that local labels given in LR operands
        can be referenced in other programs if declared with <a href="#EXT">EXT</a>.
        As such, each LR operand generates a Linking Record in the object file.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D6</td>
    <td id="d_">EXT</td>
    <td><a href="#nolabel">none</a> EXT LR:<a href="#exlabel">exlabel</a>, ...;<br/>
    <i>Multiple operands supported</i></td>
    <td>EXTernal variable name: declares the label and denotes to the linker that it will be in
        another file. Labels given to LR must not appear in this program, or they will be shadowed.
        The declared label must be declared ENT in another program against which the current program
        will be linked.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D7</td>
    <td id="d_">END</td>
    <td><a href="#nolabel">none</a> end LR:label;</td>
    <td>Denotes <b>end</b> of source; confirms to the assembler that all input has been processed.
        Lines of code after this directive will generate a warning. As a CRC, the label passed to
        LR must match the rlabel given to <a href="#d_kicko">KickO</a>.</td>
    <td>No</td>
  </tr>
  <tr>
    <td>D8</td>
    <td id="d_aexs">AEXS</td>
    <td><a href="#olabel">olabel</a> AEXS LR:<a href="#rlabel">rlabel</a>;<br/>
        <a href="#olabel">olabel</a> AEXS FC:<a href="#mlit">mlit</a>;</td>
    <td><b>A</b>lternative <b>Ex</b>ecution <b>S</b>tart: Changes the start address of this program
        to the relocatable address specified in the FC operand, or that of the label specified to
        the LR operand.</td>
    <td></td>
  </tr>
  <tr>
    <td>D9</td>
    <td id="d_skips">SKIPS</td>
    <td><a href="#olabel">olabel</a> SKIPS FC:<a href="#mlit">mlit</a>;</td>
    <td><b>Skip S</b>torage: Allocates space for the number of words specified in the FC operand.
        These words will be left as raw memory for use by the program. They will be zeroed at load.</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D10</td>
    <td id="d_char">CHAR</td>
    <td><a href="#olabel">olabel</a> CHAR ST:<a href="#strlit">strlit</a>;</td>
    <td><b>Char</b>acter Constant: Reserves a sufficient number of words to store the string literal
        given to ST, and packs them into memory. Unused bytes will be padded with blanks (0x20).</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D11</td>
    <td id="d_num">NUM</td>
    <td><a href="#olabel">olabel</a> num FC:<a href="#longlit">longlit</a>;</td>
    <td>Base 10 <b>num</b>ber in the range (-2<sup>31</sup>) to (2<sup>31</sup>-1).</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>D12</td>
    <td id="d_adrc">ADRC</td>
    <td><a href="#olabel">olabel</a> adrc LR:<a href="#rlabel">rlabel</a>;<br/>
        <a href="#olabel">olabel</a> adrc LR:<a href="#exlabel">exlabel</a>;<br/>
        <a href="#olabel">olabel</a> adrc EX:<a href="#expression">expression</a>;</td>
    <td><b>Ad</b>d<b>r</b>ess <b>C</b>onstant. Included for compatibility with other URBAN
        assemblers. Originally intended to allow storing address computations in memory;
        behavior is identical to NUM.</td>
    <td>Yes</td>
  </tr>
</table>
<p>


<h1 id="keywords">Operand Keywords<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
  To simplify format memorization, URBAN uses keywords rather than order to disambiguate
  operands to each instruction or directive.
</p><p>
  Different instructions support different operands, and different operands can be represented
  by different keywords. Some operands specify a source kind, others a destination kind. For
  instance, if an instruction takes a source and destination, keywords can be used to specify
  that the source will be a memory address while the destination is to be a register.
</p><p>
  The table below lists keywords and their unabbreviated names.
</p>


<table>
  <tr>
    <th>Keyword</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>DM</td>
    <td><b>D</b>estination <b>M</b>emory</td>
  </tr> 
  <tr>
    <td>DR</td>
    <td><b>D</b>estination <b>R</b>egister</td>
  </tr>
  <tr>
    <td>DX</td>
    <td><b>D</b>estination inde<b>x</b> Register</td>
  </tr>
  <tr>
    <td>EX</td>
    <td><b>Ex</b>pression</td>
  </tr>
  <tr>
    <td>FC</td>
    <td><b>F</b>rom <b>C</b>onstant</td>
  </tr>
  <tr>
    <td>FL</td>
    <td><b>F</b>rom <b>L</b>iteral</td>
  </tr>
  <tr>
    <td>FM</td>
    <td><b>F</b>rom <b>M</b>emory</td>
  </tr>
  <tr>
    <td>FR</td>
    <td><b>F</b>rom <b>R</b>egister</td>
  </tr>
  <tr>
    <td>FX</td>
    <td><b>F</b>rom inde<b>x</b> Register</td>
  </tr>
  <tr>
    <td>LR</td>
    <td><b>L</b>abel <b>R</b>eference</td>
  </tr>
  <tr>
    <td>NW</td>
    <td><b>N</b>umber of <b>W</b>ords</td>
    </tr>
  <tr>
    <td>ST</td>
    <td><b>St</b>ring Literal</td>
  </tr>
</table>

<p> It is valid, but discouraged, to use directive names as labels. </p>

<h1 id="instructions">Instructions<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
The following tables describe the various instructions with their formats and their binary equivalent opcodes.
</p>


<table>
<tr><th>spec key   </th><th> instruction name                              </th><th> opcode </th><th> valid operand combos                                                                                                                                                           </th><th> special ranges                           </th><th> instruction format              </th><th> description                                                                                                                                                            </th></tr>
<tr><td>MVO        </td><td> MOVD                                          </td><td> 000000 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Moves data from a register to memory loc or memory loc to a register or register to register                                                                           </td></tr>
<tr><td>MV1        </td><td> MOVDN                                         </td><td> 000001 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Moves data from a register-1 to memory lco or memory loc -1 to a register or register-1 to register                                                                    </td></tr>
<tr><td>IA0        </td><td> IADD                                          </td><td> 001000 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Adds memory loc and a register together or a register and a register                                                                                                   </td></tr>
<tr><td>IA1        </td><td> IMAD                                          </td><td> 001001 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Multiplys memory loc or register with a register or memory loc and adds memory loc or register to total                                                                </td></tr>
<tr><td>IA2        </td><td> IAA                                           </td><td> 001010 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Adds absolute value of memory loc to a register or absolute value register to memory loc or absolute register to register                                              </td></tr>
<tr><td>IA4        </td><td> ISUB                                          </td><td> 001100 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Subtracts memory loc and a register together or a register and another register                                                                                        </td></tr>
<tr><td>IA5        </td><td> IMUL                                          </td><td> 001101 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Mulitplys memory loc and a register together or a register and another register                                                                                        </td></tr>
<tr><td>IA6        </td><td> IDIV                                          </td><td> 001110 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Divides memory loc and a register together or a register and anotherregister                                                                                           </td></tr>
<tr><td>IS0        </td><td> CLR  (clear register)                         </td><td> 010000 </td><td> {DR},{DX}                                                                                                                                                                      </td><td>                                          </td><td> memory                          </td><td> clear an index or arithmetic register.                                                                                                                                 </td></tr>
<tr><td>IS1        </td><td> CLRA (clear arithmetic registers)             </td><td> 010001 </td><td> {}                                                                                                                                                                             </td><td>                                          </td><td> CLRA/CLRX                       </td><td> clears all arithmetic registers.                                                                                                                                       </td></tr>
<tr><td>IS2        </td><td> CLRX (clear index registers)                  </td><td> 010010 </td><td> {}                                                                                                                                                                             </td><td>                                          </td><td> CLRA/CLRX                       </td><td> clears all index registers.                                                                                                                                            </td></tr>
<tr><td>IM0        </td><td> ISHR (integer shift right logical)            </td><td> 011000 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC:[0,31]                                </td><td> literal                         </td><td> shifts the right given constant bits and fills all the shifted bits with 0's                                                                                           </td></tr>
<tr><td>IM1        </td><td> ISHL (integer shift left logical)             </td><td> 011001 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC:[0,31]                                </td><td> literal                         </td><td> shifts the left given constant bits and fills all the shifted bits with 0's                                                                                            </td></tr>
<tr><td>IM2        </td><td> ISRA (integer shift right arithmetic)         </td><td> 011010 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC:[0,31]                                </td><td> literal                         </td><td> shifts the right given constant bits and fills all the shifted bits with the sign bit                                                                                  </td></tr>
<tr><td>IM3        </td><td> ISLA (integer shift left arithmetic)          </td><td> 011011 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC:[0,31]                                </td><td> literal                         </td><td> shifts the left given constant bits and fills all the shifted bits with the sign bit                                                                                   </td></tr>
<tr><td>IM4        </td><td> ROL  (rotate left)                            </td><td> 011100 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC:[0,31]                                </td><td> literal                         </td><td> rotates left, including the sign bit                                                                                                                                   </td></tr>
<tr><td>IM5        </td><td> ROR  (rotate right)                           </td><td> 011101 </td><td> {FC,DR},{FC,DX},{EX,DR},{EX,DX}                                                                                                                                                </td><td> FC:[0,31]                                </td><td> literal                         </td><td> rotates right, including the sign bit                                                                                                                                  </td></tr>
<tr><td>IM6        </td><td> AND                                           </td><td> 011110 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Ands a memory loc and a register together or a register and another register                                                                                           </td></tr>
<tr><td>IM7        </td><td> OR                                            </td><td> 011111 </td><td> {FR,DM},{FM,DR},{FX,DM},{FM,DX},{FR,DM,DX},{FX,DM,DX},{FM,FX,DX},{FM,FX,DR},{FR,DR},{FR,DX},{FX,DR},{FX,DX},{FR,DM},{FL,DR},{FL,DX},{FM,DM},{FL,DM},{EX,DR},{EX,DX},{EX,DM}    </td><td> FL,EX:[-32768,32767]{DM,FL}:[-2048,2047] </td><td> mem,lit,mem + mem,mem + lit     </td><td> Ors a memory loc and a register together or a register and another register                                                                                            </td></tr>
<tr><td>JT0        </td><td> TREQ (Transfer on equal to zero)              </td><td> 100000 </td><td> {FR,DM},{FR,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> memory                          </td><td> if contents of register = 0, then jump to address given.                                                                                                               </td></tr>
<tr><td>JT1        </td><td> TRLT (Transfer on less than zero)             </td><td> 100001 </td><td> {FR,DM},{FR,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> memory                          </td><td> if contents of register < 0, then jump to address given.                                                                                                               </td></tr>
<tr><td>JT2        </td><td> TRGT (Transfer on greater than zero)          </td><td> 100010 </td><td> {FR,DM},{FR,DM,DX}                                                                                                                                                             </td><td>                                          </td><td> memory                          </td><td> if contents of register > 0, then jump to address given.                                                                                                               </td></tr>
<tr><td>JT3        </td><td> TR   (Transfer unconditionally)               </td><td> 100011 </td><td> {DM},{DM, DX}                                                                                                                                                                  </td><td>                                          </td><td> memory                          </td><td> Jumps to address given.                                                                                                                                                </td></tr>
<tr><td>JT4        </td><td> TRDR (Transfer or decrement register)         </td><td> 100100 </td><td> {FR,DM},{FR,DM,DX},{FX,DM},{FX,DM,DX}                                                                                                                                          </td><td>                                          </td><td> memory                          </td><td> Decrements contents of register and jumps to address given.                                                                                                            </td></tr>
<tr><td>JT5        </td><td> TRLK (Transfer and link)                      </td><td> 100101 </td><td> {DM, DR}, {DM,DX,DR}                                                                                                                                                           </td><td>                                          </td><td> memory                          </td><td> The Return address of the instruction is stored in register, and the instruction jumps to address given.                                                               </td></tr>
<tr><td>JT6        </td><td> RET  (Return to calling program)              </td><td> 100110 </td><td> {DM},{DM,DX}                                                                                                                                                                   </td><td>                                          </td><td> memory                          </td><td>                                                                                                                                                                        </td></tr>
<tr><td>JT7        </td><td> SKT  (Stack test)                             </td><td> 100111 </td><td> {DR}                                                                                                                                                                           </td><td>                                          </td><td> memory                          </td><td>                                                                                                                                                                        </td></tr>
<tr><td>IO0        </td><td> IWSR (integer write to screen)                </td><td> 101000 </td><td> {NW, FM, FX},{NW,FM},{NW, FL},{NW, EX}                                                                                                                                         </td><td> FL,EX:[0, 4095]                          </td><td> output                          </td><td> outputs an integer to screen from memory.                                                                                                                              </td></tr>
<tr><td>IO2        </td><td> CWSR (character write to screen)              </td><td> 101010 </td><td> {NW, FM, FX},{NW,FM},{NW, FL},{NW, EX}                                                                                                                                         </td><td> FL,EX:[0, 4095]                          </td><td> output                          </td><td> outputs a character to screen from memory.                                                                                                                             </td></tr>
<tr><td>IO1        </td><td> IRKB (integer read from keyboard)             </td><td> 101001 </td><td> {NW, DM},{NW,DM,DX}                                                                                                                                                            </td><td>                                          </td><td> input                           </td><td> inputs an integer from keyboard to memory.                                                                                                                             </td></tr>
<tr><td>IO3        </td><td> CRKB (character read from keyboard)           </td><td> 101100 </td><td> {NW, DM},{NW,DM,DX}                                                                                                                                                            </td><td>                                          </td><td> input                           </td><td> inputs a character from keyboard to memory.                                                                                                                            </td></tr>
<tr><td>S0         </td><td> PSH  (push)                                   </td><td> 110000 </td><td> {FC},{FL},{EX},{FM}                                                                                                                                                            </td><td> FL,EX:[0, 4095]                          </td><td> memory,literal                  </td><td> pushes the memory element onto the top of the stack                                                                                                                    </td></tr>
<tr><td>S1         </td><td> POP  (pop)                                    </td><td> 110001 </td><td> {DR},{DM}                                                                                                                                                                      </td><td> FL,EX:[0, 4095]                          </td><td> memory,literal                  </td><td> pops the top stack element into memory or register.                                                                                                                    </td></tr>
<tr><td>S2         </td><td> PST  (pop and test)                           </td><td> 110010 </td><td> {FM,DR},{FM,FX,DR},{FL,DR},{EX,DR}                                                                                                                                             </td><td> FL,EX:[0, 4095]                          </td><td> memory,literal                  </td><td> pops the top stack element, and compares the element with memory or literal: if = then load DR with 0; if != load DR with 1; if < load DR with 2; if > load DR with 3. </td></tr>
<tr><td>C0         </td><td> NOP (no-operation)                            </td><td> 111101 </td><td> {}                                                                                                                                                                             </td><td>                                          </td><td> 0xF4000000                      </td><td> no operation.                                                                                                                                                          </td></tr>
<tr><td>C2         </td><td> HLT (halt)                                    </td><td> 111110 </td><td> {FC},{EX}                                                                                                                                                                      </td><td> FC:[-4096, 4095]                         </td><td> halt/dump                       </td><td> halts the program, and displays the constant to screen.                                                                                                                </td></tr>
<tr><td>C1         </td><td> DMP (dump)                                    </td><td> 111111 </td><td> {FC},{EX}                                                                                                                                                                      </td><td> FC:[1,3]                                 </td><td> halt/dump                       </td><td> displays register and memory contents to screen.  if fc = 1, then level 1 dump; if fc = 2, then level 2 dump; if fc = 3, then level 3 dump.                            </td></tr>
</table>

<h1 id="objfile">Object File Specification<a href="#toc" class="backlink">Back to Top</a></h1>

<table>
  <tr>
    <th colspan="4">Spec Ref</th>
    <th width="15%">Format</th>
    <th>Description</th>
  </tr>
  	<tr>
		<td colspan="4" id="OB2">OB2</td>
		<td colspan="2">Linking Record</td>
	</tr>
	<tr>
		<td rowspan="7" class="stripebg"></td>
		<td colspan="3" id="OB2.1">OB2.1</td>
		<td>Byte('L')</td>
		<td>Linking record indicator</td>
	</tr>
	<tr>
		<td colspan="3" id="OB2.2">OB2.2</td>
		<td>Byte(':')</td>
		<td>Standard separator</td>
	</tr>
	<tr>
		<td colspan="3" id="OB2.3">OB2.3</td>
		<td>LABEL, 1-32 Bytes</td>
		<td>Entry Label</td>
	</tr>
	<tr>
		<td colspan="3" id="OB2.4">OB2.4</td>
		<td>Byte(':')</td>
		<td>Standard separator</td>
	</tr>
	<tr>
		<td colspan="3" id="OB2.5">OB2.5</td>
		<td>Short, HHHH</td>
		<td>Entry Address (4 hex nybbles)</td>
	</tr>
	<tr>
		<td colspan="3" id="OB2.6">OB2.6</td>
		<td>Byte(':')</td>
		<td>Standard separator</td>
	</tr>
    <tr>
		<td colspan="3" id="OB2.7">OB2.7</td>
		<td>LABEL, 1-32 bytes</td>
		<td>Program Name, same as <a href="OB1.3">OB1.3</a></td>
    </tr>
    <tr>
      <td colspan="4" id="OB4">OB4</td>
      <td colspan="2">Modification Record</td>
    </tr>
    <tr>
      <td rowspan="16" class="stripebg"></td>
      <td colspan="3" id="OB4.1">OB4.1</td>
      <td>Byte('M')</td>
      <td>Modification record indicator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.2">OB4.2</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.3">OB4.3</td>
      <td>Short, HHHH</td>
      <td>Four hex nybbles</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.4">OB4.4</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.5">OB4.5</td>
      <td>CHUNK</td>
      <td>Adjustment Chunk: One per link-time adjustment</td>
    </tr>
       <tr>
         <td rowspan="6" class="stripebg"></td>
         <td colspan="2" id="OB4.5.1">OB4.5.1</td>
         <td>Byte('+' or '-')</td>
         <td>The sign of this adjustment; a '+' indicates that the adjustment is added, a '-' denotes that
         it is instead subtracted.</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.2">OB4.5.2</td>
         <td>Byte(':')</td>
         <td>Standard separator</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.3">OB4.5.3</td>
         <td>Byte('R' or 'E')</td>
         <td>Address type flag of the label that needs adjustment.</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.4">OB4.5.4</td>
         <td>Byte(':')</td>
         <td>Standard separator</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.5">OB4.5.5</td>
         <td>LABEL, 1-32 Bytes</td>
         <td>The label whose address the linker will use to adjust this record</td>
       </tr>
       <tr>
         <td colspan="2" id="OB4.5.6">OB4.5.6</td>
         <td>Byte(':')</td>
         <td>Standard separator</td>
       </tr>
    <tr>
      <td colspan="3" id="OB4.6">OB4.6</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.7">OB4.7</td>
      <td>Byte('H' or 'L' or 'S')</td>
      <td>High- or Low-order Address. 'H' if bits 9-20 are to be considered, 'L' 
          if bits 20-32 are to be considered, 'S' if this was a Single-address
          instruction.</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.8">OB4.8</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.9">OB4.9</td>
      <td>LABEL, 1-32 bytes</td>
      <td>Program Name, same as <a href="OB1.3">OB1.3</a></td>
    </tr>
    <tr>
      <td colspan="3" id="OB4.10">OB4.10</td>
      <td>Byte(':')</td>
      <td>Standard separator</td>
    </tr>
  <tr>
    <td colspan="4" id=""></td>
    <td></td>
    <td></td>
  </tr>
</table>


<h1 id="sampleio">URBAN Legend Input and Output Description and Format<a href="#toc" class="backlink">Back to Top</a></h1>
<p>
<h5>URBAN Legend Input:</h5>
        Enter program in GUI as described in the <a href="user_start.html">How to run Urban</a>
</p>
 
<h5>URBAN Legend output format:</h5>
"URBAN Legend" followed by version number.
e.g. URBAN Legend v1

"Usage: java -jar urban.jar file1 file2 file3... -o executablename" <br>

"Assembling " followed by file paths of files to assemble. <br>
e.g. Assembling C:\\Users\\User/Desktop/test.s <br>
<p> 
"Symbol Table:" followed by the symbol table. <br>
each line of symbol table displays: label address usage equString <br>
label is the label of the instruction in the symbol table. <br>
address is the instruction's address. <br>
usage is one of the following: <br>
	<pre>
        LABEL, PROGNAME, EXTERNAL, EQUATE, or ENTRY.
		 LABEL is when the label is used as a label.
		 PROGNAME is when the label is used as a module name.
		 EXTERNAL is when the label is used as an external label.
		 EQUATE is when the label is being equated to the equString.
		 ENTRY is when the label is used as an entry label.
	</pre>
equString is only used by instructions with the EQUATE usage.
       It is what the label is being equated to. <br>
e.g. <br> <pre>
        Symbol Table:
        ALT1 0 LABEL
        blah 18 LABEL
        C1 26 LABEL
        C4 27 LABEL
        DONE 17 LABEL
        ER 21 LABEL
        M1 31 LABEL
        M2 36 LABEL
        ME 29 LABEL
        P1 1 LABEL
        P2 4 LABEL
        Q1 1 LABEL
        QQ 4 LABEL
        TP 2 LABEL
        XX 4 LABEL
        YY 4 LABEL
</pre>
<p> 
"Instruction breakdowns:" followed by a list of the breakdowns of each instruction in the module. <br>
each instruction breakdown is as follows: <br>
		<pre>
        "original source line: " origSrcLine.
        "Line number:" lineNum " LC: " addr " Label: " label ","
        "instruction/Directive: " inst/dir " Binary Equivalent: " binInst/dir
        "Operand 1: " operKey ":" operVal
        "Operand 2: " operKey ":" operVal
        "Operand 3: " operKey ":" operVal
        "Operand 4: " operKey ":" operVal
		</pre>
</p>
<p>       
        origSrcLine is the original source line that the assembler parsed. <br>
        lineNum is the line number in the source file that the source line appeared. <br>
        addr is the address of the instruction i.e. lc. <br>
        label is the label of the instruction if there is one. <br>
        inst/dir is the type of instruction/directive e.g. MOVD or KICKO <br>
        binInst/dir is the opcode for the instruction. if the instruction is a directive, then "------" is displayed in place of opcode. <br>
        operKey is the keyword for the operand. <br>
        operVal is the value of the operand. <br>
        if there are less than 4 operands, however many operands there are in the instruction are displayed. <br>
</p>
e.g. <br><pre>
        original source line: IWSR FM:Q1,NW:1;
        Line number: 22 LC: 0013 Label: ,
        instruction/Directive: IWSR Binary Equivalent: 101000
        Operand 1: FM:Q1
        Operand 2: NW:1
	</pre>
</p> 
<p>
<a href="#MENU">Back to Menu</a>
</p> 

*/
